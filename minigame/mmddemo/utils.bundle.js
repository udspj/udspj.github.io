!function(r){var n={};function e(t){if(n[t])return n[t].exports;var a=n[t]={i:t,l:!1,exports:{}};return r[t].call(a.exports,a,a.exports,e),a.l=!0,a.exports}e.m=r,e.c=n,e.d=function(r,n,t){e.o(r,n)||Object.defineProperty(r,n,{enumerable:!0,get:t})},e.r=function(r){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(r,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(r,"__esModule",{value:!0})},e.t=function(r,n){if(1&n&&(r=e(r)),8&n)return r;if(4&n&&"object"==typeof r&&r&&r.__esModule)return r;var t=Object.create(null);if(e.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:r}),2&n&&"string"!=typeof r)for(var a in r)e.d(t,a,function(n){return r[n]}.bind(null,a));return t},e.n=function(r){var n=r&&r.__esModule?function(){return r.default}:function(){return r};return e.d(n,"a",n),n},e.o=function(r,n){return Object.prototype.hasOwnProperty.call(r,n)},e.p="",e(e.s=17)}([function(r,n){r.exports=function(r){function n(r){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",r)}try{"undefined"!=typeof execScript&&"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener?execScript(r):"undefined"!=typeof eval?eval.call(null,r):n("EvalError: No eval function available")}catch(r){n(r)}}},,,,,,,,,,,,,,,,,function(r,n,e){"use strict";e.r(n);e(18),e(20),e(22),e(24)},function(r,n,e){e(0)(e(19))},function(r,n){r.exports="// cuon-utils.js (c) 2012 kanda and matsuda\r\n/**\r\n * Create a program object and make current\r\n * @param gl GL context\r\n * @param vshader a vertex shader program (string)\r\n * @param fshader a fragment shader program (string)\r\n * @return true, if the program object was created and successfully made current \r\n */\r\nfunction initShaders(gl, vshader, fshader) {\r\n  var program = createProgram(gl, vshader, fshader);\r\n  if (!program) {\r\n    console.log('Failed to create program');\r\n    return false;\r\n  }\r\n\r\n  gl.useProgram(program);\r\n  gl.program = program;\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Create the linked program object\r\n * @param gl GL context\r\n * @param vshader a vertex shader program (string)\r\n * @param fshader a fragment shader program (string)\r\n * @return created program object, or null if the creation has failed\r\n */\r\nfunction createProgram(gl, vshader, fshader) {\r\n  // Create shader object\r\n  var vertexShader = loadShader(gl, gl.VERTEX_SHADER, vshader);\r\n  var fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fshader);\r\n  if (!vertexShader || !fragmentShader) {\r\n    return null;\r\n  }\r\n\r\n  // Create a program object\r\n  var program = gl.createProgram();\r\n  if (!program) {\r\n    return null;\r\n  }\r\n\r\n  // Attach the shader objects\r\n  gl.attachShader(program, vertexShader);\r\n  gl.attachShader(program, fragmentShader);\r\n\r\n  // Link the program object\r\n  gl.linkProgram(program);\r\n\r\n  // Check the result of linking\r\n  var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n  if (!linked) {\r\n    var error = gl.getProgramInfoLog(program);\r\n    console.log('Failed to link program: ' + error);\r\n    gl.deleteProgram(program);\r\n    gl.deleteShader(fragmentShader);\r\n    gl.deleteShader(vertexShader);\r\n    return null;\r\n  }\r\n  return program;\r\n}\r\n\r\n/**\r\n * Create a shader object\r\n * @param gl GL context\r\n * @param type the type of the shader object to be created\r\n * @param source shader program (string)\r\n * @return created shader object, or null if the creation has failed.\r\n */\r\nfunction loadShader(gl, type, source) {\r\n  // Create shader object\r\n  var shader = gl.createShader(type);\r\n  if (shader == null) {\r\n    console.log('unable to create shader');\r\n    return null;\r\n  }\r\n\r\n  // Set the shader program\r\n  gl.shaderSource(shader, source);\r\n\r\n  // Compile the shader\r\n  gl.compileShader(shader);\r\n\r\n  // Check the result of compilation\r\n  var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n  if (!compiled) {\r\n    var error = gl.getShaderInfoLog(shader);\r\n    console.log('Failed to compile shader: ' + error);\r\n    gl.deleteShader(shader);\r\n    return null;\r\n  }\r\n\r\n  return shader;\r\n}\r\n\r\n/** \r\n * Initialize and get the rendering for WebGL\r\n * @param canvas <cavnas> element\r\n * @param opt_debug flag to initialize the context for debugging\r\n * @return the rendering context for WebGL\r\n */\r\nfunction getWebGLContext(canvas, opt_debug) {\r\n  // Get the rendering context for WebGL\r\n  var gl = WebGLUtils.setupWebGL(canvas);\r\n  if (!gl) return null;\r\n\r\n  // if opt_debug is explicitly false, create the context for debugging\r\n  if (arguments.length < 2 || opt_debug) {\r\n    gl = WebGLDebugUtils.makeDebugContext(gl);\r\n  }\r\n\r\n  return gl;\r\n}\r\n"},function(r,n,e){e(0)(e(21))},function(r,n){r.exports="// cuon-matrix.js (c) 2012 kanda and matsuda\r\n/** \r\n * This is a class treating 4x4 matrix.\r\n * This class contains the function that is equivalent to OpenGL matrix stack.\r\n * The matrix after conversion is calculated by multiplying a conversion matrix from the right.\r\n * The matrix is replaced by the calculated result.\r\n */\r\n\r\n/**\r\n * Constructor of Matrix4\r\n * If opt_src is specified, new matrix is initialized by opt_src.\r\n * Otherwise, new matrix is initialized by identity matrix.\r\n * @param opt_src source matrix(option)\r\n */\r\nvar Matrix4 = function(opt_src) {\r\n  var i, s, d;\r\n  if (opt_src && typeof opt_src === 'object' && opt_src.hasOwnProperty('elements')) {\r\n    s = opt_src.elements;\r\n    d = new Float32Array(16);\r\n    for (i = 0; i < 16; ++i) {\r\n      d[i] = s[i];\r\n    }\r\n    this.elements = d;\r\n  } else {\r\n    this.elements = new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);\r\n  }\r\n};\r\n\r\n/**\r\n * Set the identity matrix.\r\n * @return this\r\n */\r\nMatrix4.prototype.setIdentity = function() {\r\n  var e = this.elements;\r\n  e[0] = 1;   e[4] = 0;   e[8]  = 0;   e[12] = 0;\r\n  e[1] = 0;   e[5] = 1;   e[9]  = 0;   e[13] = 0;\r\n  e[2] = 0;   e[6] = 0;   e[10] = 1;   e[14] = 0;\r\n  e[3] = 0;   e[7] = 0;   e[11] = 0;   e[15] = 1;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Copy matrix.\r\n * @param src source matrix\r\n * @return this\r\n */\r\nMatrix4.prototype.set = function(src) {\r\n  var i, s, d;\r\n\r\n  s = src.elements;\r\n  d = this.elements;\r\n\r\n  if (s === d) {\r\n    return;\r\n  }\r\n    \r\n  for (i = 0; i < 16; ++i) {\r\n    d[i] = s[i];\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Multiply the matrix from the right.\r\n * @param other The multiply matrix\r\n * @return this\r\n */\r\nMatrix4.prototype.concat = function(other) {\r\n  var i, e, a, b, ai0, ai1, ai2, ai3;\r\n  \r\n  // Calculate e = a * b\r\n  e = this.elements;\r\n  a = this.elements;\r\n  b = other.elements;\r\n  \r\n  // If e equals b, copy b to temporary matrix.\r\n  if (e === b) {\r\n    b = new Float32Array(16);\r\n    for (i = 0; i < 16; ++i) {\r\n      b[i] = e[i];\r\n    }\r\n  }\r\n  \r\n  for (i = 0; i < 4; i++) {\r\n    ai0=a[i];  ai1=a[i+4];  ai2=a[i+8];  ai3=a[i+12];\r\n    e[i]    = ai0 * b[0]  + ai1 * b[1]  + ai2 * b[2]  + ai3 * b[3];\r\n    e[i+4]  = ai0 * b[4]  + ai1 * b[5]  + ai2 * b[6]  + ai3 * b[7];\r\n    e[i+8]  = ai0 * b[8]  + ai1 * b[9]  + ai2 * b[10] + ai3 * b[11];\r\n    e[i+12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];\r\n  }\r\n  \r\n  return this;\r\n};\r\nMatrix4.prototype.multiply = Matrix4.prototype.concat;\r\n\r\n/**\r\n * Multiply the three-dimensional vector.\r\n * @param pos  The multiply vector\r\n * @return The result of multiplication(Float32Array)\r\n */\r\nMatrix4.prototype.multiplyVector3 = function(pos) {\r\n  var e = this.elements;\r\n  var p = pos.elements;\r\n  var v = new Vector3();\r\n  var result = v.elements;\r\n\r\n  result[0] = p[0] * e[0] + p[1] * e[4] + p[2] * e[ 8] + e[11];\r\n  result[1] = p[0] * e[1] + p[1] * e[5] + p[2] * e[ 9] + e[12];\r\n  result[2] = p[0] * e[2] + p[1] * e[6] + p[2] * e[10] + e[13];\r\n\r\n  return v;\r\n};\r\n\r\n/**\r\n * Multiply the four-dimensional vector.\r\n * @param pos  The multiply vector\r\n * @return The result of multiplication(Float32Array)\r\n */\r\nMatrix4.prototype.multiplyVector4 = function(pos) {\r\n  var e = this.elements;\r\n  var p = pos.elements;\r\n  var v = new Vector4();\r\n  var result = v.elements;\r\n\r\n  result[0] = p[0] * e[0] + p[1] * e[4] + p[2] * e[ 8] + p[3] * e[12];\r\n  result[1] = p[0] * e[1] + p[1] * e[5] + p[2] * e[ 9] + p[3] * e[13];\r\n  result[2] = p[0] * e[2] + p[1] * e[6] + p[2] * e[10] + p[3] * e[14];\r\n  result[3] = p[0] * e[3] + p[1] * e[7] + p[2] * e[11] + p[3] * e[15];\r\n\r\n  return v;\r\n};\r\n\r\n/**\r\n * Transpose the matrix.\r\n * @return this\r\n */\r\nMatrix4.prototype.transpose = function() {\r\n  var e, t;\r\n\r\n  e = this.elements;\r\n\r\n  t = e[ 1];  e[ 1] = e[ 4];  e[ 4] = t;\r\n  t = e[ 2];  e[ 2] = e[ 8];  e[ 8] = t;\r\n  t = e[ 3];  e[ 3] = e[12];  e[12] = t;\r\n  t = e[ 6];  e[ 6] = e[ 9];  e[ 9] = t;\r\n  t = e[ 7];  e[ 7] = e[13];  e[13] = t;\r\n  t = e[11];  e[11] = e[14];  e[14] = t;\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Calculate the inverse matrix of specified matrix, and set to this.\r\n * @param other The source matrix\r\n * @return this\r\n */\r\nMatrix4.prototype.setInverseOf = function(other) {\r\n  var i, s, d, inv, det;\r\n\r\n  s = other.elements;\r\n  d = this.elements;\r\n  inv = new Float32Array(16);\r\n\r\n  inv[0]  =   s[5]*s[10]*s[15] - s[5] *s[11]*s[14] - s[9] *s[6]*s[15]\r\n            + s[9]*s[7] *s[14] + s[13]*s[6] *s[11] - s[13]*s[7]*s[10];\r\n  inv[4]  = - s[4]*s[10]*s[15] + s[4] *s[11]*s[14] + s[8] *s[6]*s[15]\r\n            - s[8]*s[7] *s[14] - s[12]*s[6] *s[11] + s[12]*s[7]*s[10];\r\n  inv[8]  =   s[4]*s[9] *s[15] - s[4] *s[11]*s[13] - s[8] *s[5]*s[15]\r\n            + s[8]*s[7] *s[13] + s[12]*s[5] *s[11] - s[12]*s[7]*s[9];\r\n  inv[12] = - s[4]*s[9] *s[14] + s[4] *s[10]*s[13] + s[8] *s[5]*s[14]\r\n            - s[8]*s[6] *s[13] - s[12]*s[5] *s[10] + s[12]*s[6]*s[9];\r\n\r\n  inv[1]  = - s[1]*s[10]*s[15] + s[1] *s[11]*s[14] + s[9] *s[2]*s[15]\r\n            - s[9]*s[3] *s[14] - s[13]*s[2] *s[11] + s[13]*s[3]*s[10];\r\n  inv[5]  =   s[0]*s[10]*s[15] - s[0] *s[11]*s[14] - s[8] *s[2]*s[15]\r\n            + s[8]*s[3] *s[14] + s[12]*s[2] *s[11] - s[12]*s[3]*s[10];\r\n  inv[9]  = - s[0]*s[9] *s[15] + s[0] *s[11]*s[13] + s[8] *s[1]*s[15]\r\n            - s[8]*s[3] *s[13] - s[12]*s[1] *s[11] + s[12]*s[3]*s[9];\r\n  inv[13] =   s[0]*s[9] *s[14] - s[0] *s[10]*s[13] - s[8] *s[1]*s[14]\r\n            + s[8]*s[2] *s[13] + s[12]*s[1] *s[10] - s[12]*s[2]*s[9];\r\n\r\n  inv[2]  =   s[1]*s[6]*s[15] - s[1] *s[7]*s[14] - s[5] *s[2]*s[15]\r\n            + s[5]*s[3]*s[14] + s[13]*s[2]*s[7]  - s[13]*s[3]*s[6];\r\n  inv[6]  = - s[0]*s[6]*s[15] + s[0] *s[7]*s[14] + s[4] *s[2]*s[15]\r\n            - s[4]*s[3]*s[14] - s[12]*s[2]*s[7]  + s[12]*s[3]*s[6];\r\n  inv[10] =   s[0]*s[5]*s[15] - s[0] *s[7]*s[13] - s[4] *s[1]*s[15]\r\n            + s[4]*s[3]*s[13] + s[12]*s[1]*s[7]  - s[12]*s[3]*s[5];\r\n  inv[14] = - s[0]*s[5]*s[14] + s[0] *s[6]*s[13] + s[4] *s[1]*s[14]\r\n            - s[4]*s[2]*s[13] - s[12]*s[1]*s[6]  + s[12]*s[2]*s[5];\r\n\r\n  inv[3]  = - s[1]*s[6]*s[11] + s[1]*s[7]*s[10] + s[5]*s[2]*s[11]\r\n            - s[5]*s[3]*s[10] - s[9]*s[2]*s[7]  + s[9]*s[3]*s[6];\r\n  inv[7]  =   s[0]*s[6]*s[11] - s[0]*s[7]*s[10] - s[4]*s[2]*s[11]\r\n            + s[4]*s[3]*s[10] + s[8]*s[2]*s[7]  - s[8]*s[3]*s[6];\r\n  inv[11] = - s[0]*s[5]*s[11] + s[0]*s[7]*s[9]  + s[4]*s[1]*s[11]\r\n            - s[4]*s[3]*s[9]  - s[8]*s[1]*s[7]  + s[8]*s[3]*s[5];\r\n  inv[15] =   s[0]*s[5]*s[10] - s[0]*s[6]*s[9]  - s[4]*s[1]*s[10]\r\n            + s[4]*s[2]*s[9]  + s[8]*s[1]*s[6]  - s[8]*s[2]*s[5];\r\n\r\n  det = s[0]*inv[0] + s[1]*inv[4] + s[2]*inv[8] + s[3]*inv[12];\r\n  if (det === 0) {\r\n    return this;\r\n  }\r\n\r\n  det = 1 / det;\r\n  for (i = 0; i < 16; i++) {\r\n    d[i] = inv[i] * det;\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Calculate the inverse matrix of this, and set to this.\r\n * @return this\r\n */\r\nMatrix4.prototype.invert = function() {\r\n  return this.setInverseOf(this);\r\n};\r\n\r\n/**\r\n * Set the orthographic projection matrix.\r\n * @param left The coordinate of the left of clipping plane.\r\n * @param right The coordinate of the right of clipping plane.\r\n * @param bottom The coordinate of the bottom of clipping plane.\r\n * @param top The coordinate of the top top clipping plane.\r\n * @param near The distances to the nearer depth clipping plane. This value is minus if the plane is to be behind the viewer.\r\n * @param far The distances to the farther depth clipping plane. This value is minus if the plane is to be behind the viewer.\r\n * @return this\r\n */\r\nMatrix4.prototype.setOrtho = function(left, right, bottom, top, near, far) {\r\n  var e, rw, rh, rd;\r\n\r\n  if (left === right || bottom === top || near === far) {\r\n    throw 'null frustum';\r\n  }\r\n\r\n  rw = 1 / (right - left);\r\n  rh = 1 / (top - bottom);\r\n  rd = 1 / (far - near);\r\n\r\n  e = this.elements;\r\n\r\n  e[0]  = 2 * rw;\r\n  e[1]  = 0;\r\n  e[2]  = 0;\r\n  e[3]  = 0;\r\n\r\n  e[4]  = 0;\r\n  e[5]  = 2 * rh;\r\n  e[6]  = 0;\r\n  e[7]  = 0;\r\n\r\n  e[8]  = 0;\r\n  e[9]  = 0;\r\n  e[10] = -2 * rd;\r\n  e[11] = 0;\r\n\r\n  e[12] = -(right + left) * rw;\r\n  e[13] = -(top + bottom) * rh;\r\n  e[14] = -(far + near) * rd;\r\n  e[15] = 1;\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Multiply the orthographic projection matrix from the right.\r\n * @param left The coordinate of the left of clipping plane.\r\n * @param right The coordinate of the right of clipping plane.\r\n * @param bottom The coordinate of the bottom of clipping plane.\r\n * @param top The coordinate of the top top clipping plane.\r\n * @param near The distances to the nearer depth clipping plane. This value is minus if the plane is to be behind the viewer.\r\n * @param far The distances to the farther depth clipping plane. This value is minus if the plane is to be behind the viewer.\r\n * @return this\r\n */\r\nMatrix4.prototype.ortho = function(left, right, bottom, top, near, far) {\r\n  return this.concat(new Matrix4().setOrtho(left, right, bottom, top, near, far));\r\n};\r\n\r\n/**\r\n * Set the perspective projection matrix.\r\n * @param left The coordinate of the left of clipping plane.\r\n * @param right The coordinate of the right of clipping plane.\r\n * @param bottom The coordinate of the bottom of clipping plane.\r\n * @param top The coordinate of the top top clipping plane.\r\n * @param near The distances to the nearer depth clipping plane. This value must be plus value.\r\n * @param far The distances to the farther depth clipping plane. This value must be plus value.\r\n * @return this\r\n */\r\nMatrix4.prototype.setFrustum = function(left, right, bottom, top, near, far) {\r\n  var e, rw, rh, rd;\r\n\r\n  if (left === right || top === bottom || near === far) {\r\n    throw 'null frustum';\r\n  }\r\n  if (near <= 0) {\r\n    throw 'near <= 0';\r\n  }\r\n  if (far <= 0) {\r\n    throw 'far <= 0';\r\n  }\r\n\r\n  rw = 1 / (right - left);\r\n  rh = 1 / (top - bottom);\r\n  rd = 1 / (far - near);\r\n\r\n  e = this.elements;\r\n\r\n  e[ 0] = 2 * near * rw;\r\n  e[ 1] = 0;\r\n  e[ 2] = 0;\r\n  e[ 3] = 0;\r\n\r\n  e[ 4] = 0;\r\n  e[ 5] = 2 * near * rh;\r\n  e[ 6] = 0;\r\n  e[ 7] = 0;\r\n\r\n  e[ 8] = (right + left) * rw;\r\n  e[ 9] = (top + bottom) * rh;\r\n  e[10] = -(far + near) * rd;\r\n  e[11] = -1;\r\n\r\n  e[12] = 0;\r\n  e[13] = 0;\r\n  e[14] = -2 * near * far * rd;\r\n  e[15] = 0;\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Multiply the perspective projection matrix from the right.\r\n * @param left The coordinate of the left of clipping plane.\r\n * @param right The coordinate of the right of clipping plane.\r\n * @param bottom The coordinate of the bottom of clipping plane.\r\n * @param top The coordinate of the top top clipping plane.\r\n * @param near The distances to the nearer depth clipping plane. This value must be plus value.\r\n * @param far The distances to the farther depth clipping plane. This value must be plus value.\r\n * @return this\r\n */\r\nMatrix4.prototype.frustum = function(left, right, bottom, top, near, far) {\r\n  return this.concat(new Matrix4().setFrustum(left, right, bottom, top, near, far));\r\n};\r\n\r\n/**\r\n * Set the perspective projection matrix by fovy and aspect.\r\n * @param fovy The angle between the upper and lower sides of the frustum.\r\n * @param aspect The aspect ratio of the frustum. (width/height)\r\n * @param near The distances to the nearer depth clipping plane. This value must be plus value.\r\n * @param far The distances to the farther depth clipping plane. This value must be plus value.\r\n * @return this\r\n */\r\nMatrix4.prototype.setPerspective = function(fovy, aspect, near, far) {\r\n  var e, rd, s, ct;\r\n\r\n  if (near === far || aspect === 0) {\r\n    throw 'null frustum';\r\n  }\r\n  if (near <= 0) {\r\n    throw 'near <= 0';\r\n  }\r\n  if (far <= 0) {\r\n    throw 'far <= 0';\r\n  }\r\n\r\n  fovy = Math.PI * fovy / 180 / 2;\r\n  s = Math.sin(fovy);\r\n  if (s === 0) {\r\n    throw 'null frustum';\r\n  }\r\n\r\n  rd = 1 / (far - near);\r\n  ct = Math.cos(fovy) / s;\r\n\r\n  e = this.elements;\r\n\r\n  e[0]  = ct / aspect;\r\n  e[1]  = 0;\r\n  e[2]  = 0;\r\n  e[3]  = 0;\r\n\r\n  e[4]  = 0;\r\n  e[5]  = ct;\r\n  e[6]  = 0;\r\n  e[7]  = 0;\r\n\r\n  e[8]  = 0;\r\n  e[9]  = 0;\r\n  e[10] = -(far + near) * rd;\r\n  e[11] = -1;\r\n\r\n  e[12] = 0;\r\n  e[13] = 0;\r\n  e[14] = -2 * near * far * rd;\r\n  e[15] = 0;\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Multiply the perspective projection matrix from the right.\r\n * @param fovy The angle between the upper and lower sides of the frustum.\r\n * @param aspect The aspect ratio of the frustum. (width/height)\r\n * @param near The distances to the nearer depth clipping plane. This value must be plus value.\r\n * @param far The distances to the farther depth clipping plane. This value must be plus value.\r\n * @return this\r\n */\r\nMatrix4.prototype.perspective = function(fovy, aspect, near, far) {\r\n  return this.concat(new Matrix4().setPerspective(fovy, aspect, near, far));\r\n};\r\n\r\n/**\r\n * Set the matrix for scaling.\r\n * @param x The scale factor along the X axis\r\n * @param y The scale factor along the Y axis\r\n * @param z The scale factor along the Z axis\r\n * @return this\r\n */\r\nMatrix4.prototype.setScale = function(x, y, z) {\r\n  var e = this.elements;\r\n  e[0] = x;  e[4] = 0;  e[8]  = 0;  e[12] = 0;\r\n  e[1] = 0;  e[5] = y;  e[9]  = 0;  e[13] = 0;\r\n  e[2] = 0;  e[6] = 0;  e[10] = z;  e[14] = 0;\r\n  e[3] = 0;  e[7] = 0;  e[11] = 0;  e[15] = 1;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Multiply the matrix for scaling from the right.\r\n * @param x The scale factor along the X axis\r\n * @param y The scale factor along the Y axis\r\n * @param z The scale factor along the Z axis\r\n * @return this\r\n */\r\nMatrix4.prototype.scale = function(x, y, z) {\r\n  var e = this.elements;\r\n  e[0] *= x;  e[4] *= y;  e[8]  *= z;\r\n  e[1] *= x;  e[5] *= y;  e[9]  *= z;\r\n  e[2] *= x;  e[6] *= y;  e[10] *= z;\r\n  e[3] *= x;  e[7] *= y;  e[11] *= z;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set the matrix for translation.\r\n * @param x The X value of a translation.\r\n * @param y The Y value of a translation.\r\n * @param z The Z value of a translation.\r\n * @return this\r\n */\r\nMatrix4.prototype.setTranslate = function(x, y, z) {\r\n  var e = this.elements;\r\n  e[0] = 1;  e[4] = 0;  e[8]  = 0;  e[12] = x;\r\n  e[1] = 0;  e[5] = 1;  e[9]  = 0;  e[13] = y;\r\n  e[2] = 0;  e[6] = 0;  e[10] = 1;  e[14] = z;\r\n  e[3] = 0;  e[7] = 0;  e[11] = 0;  e[15] = 1;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Multiply the matrix for translation from the right.\r\n * @param x The X value of a translation.\r\n * @param y The Y value of a translation.\r\n * @param z The Z value of a translation.\r\n * @return this\r\n */\r\nMatrix4.prototype.translate = function(x, y, z) {\r\n  var e = this.elements;\r\n  e[12] += e[0] * x + e[4] * y + e[8]  * z;\r\n  e[13] += e[1] * x + e[5] * y + e[9]  * z;\r\n  e[14] += e[2] * x + e[6] * y + e[10] * z;\r\n  e[15] += e[3] * x + e[7] * y + e[11] * z;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set the matrix for rotation.\r\n * The vector of rotation axis may not be normalized.\r\n * @param angle The angle of rotation (degrees)\r\n * @param x The X coordinate of vector of rotation axis.\r\n * @param y The Y coordinate of vector of rotation axis.\r\n * @param z The Z coordinate of vector of rotation axis.\r\n * @return this\r\n */\r\nMatrix4.prototype.setRotate = function(angle, x, y, z) {\r\n  var e, s, c, len, rlen, nc, xy, yz, zx, xs, ys, zs;\r\n\r\n  angle = Math.PI * angle / 180;\r\n  e = this.elements;\r\n\r\n  s = Math.sin(angle);\r\n  c = Math.cos(angle);\r\n\r\n  if (0 !== x && 0 === y && 0 === z) {\r\n    // Rotation around X axis\r\n    if (x < 0) {\r\n      s = -s;\r\n    }\r\n    e[0] = 1;  e[4] = 0;  e[ 8] = 0;  e[12] = 0;\r\n    e[1] = 0;  e[5] = c;  e[ 9] =-s;  e[13] = 0;\r\n    e[2] = 0;  e[6] = s;  e[10] = c;  e[14] = 0;\r\n    e[3] = 0;  e[7] = 0;  e[11] = 0;  e[15] = 1;\r\n  } else if (0 === x && 0 !== y && 0 === z) {\r\n    // Rotation around Y axis\r\n    if (y < 0) {\r\n      s = -s;\r\n    }\r\n    e[0] = c;  e[4] = 0;  e[ 8] = s;  e[12] = 0;\r\n    e[1] = 0;  e[5] = 1;  e[ 9] = 0;  e[13] = 0;\r\n    e[2] =-s;  e[6] = 0;  e[10] = c;  e[14] = 0;\r\n    e[3] = 0;  e[7] = 0;  e[11] = 0;  e[15] = 1;\r\n  } else if (0 === x && 0 === y && 0 !== z) {\r\n    // Rotation around Z axis\r\n    if (z < 0) {\r\n      s = -s;\r\n    }\r\n    e[0] = c;  e[4] =-s;  e[ 8] = 0;  e[12] = 0;\r\n    e[1] = s;  e[5] = c;  e[ 9] = 0;  e[13] = 0;\r\n    e[2] = 0;  e[6] = 0;  e[10] = 1;  e[14] = 0;\r\n    e[3] = 0;  e[7] = 0;  e[11] = 0;  e[15] = 1;\r\n  } else {\r\n    // Rotation around another axis\r\n    len = Math.sqrt(x*x + y*y + z*z);\r\n    if (len !== 1) {\r\n      rlen = 1 / len;\r\n      x *= rlen;\r\n      y *= rlen;\r\n      z *= rlen;\r\n    }\r\n    nc = 1 - c;\r\n    xy = x * y;\r\n    yz = y * z;\r\n    zx = z * x;\r\n    xs = x * s;\r\n    ys = y * s;\r\n    zs = z * s;\r\n\r\n    e[ 0] = x*x*nc +  c;\r\n    e[ 1] = xy *nc + zs;\r\n    e[ 2] = zx *nc - ys;\r\n    e[ 3] = 0;\r\n\r\n    e[ 4] = xy *nc - zs;\r\n    e[ 5] = y*y*nc +  c;\r\n    e[ 6] = yz *nc + xs;\r\n    e[ 7] = 0;\r\n\r\n    e[ 8] = zx *nc + ys;\r\n    e[ 9] = yz *nc - xs;\r\n    e[10] = z*z*nc +  c;\r\n    e[11] = 0;\r\n\r\n    e[12] = 0;\r\n    e[13] = 0;\r\n    e[14] = 0;\r\n    e[15] = 1;\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Multiply the matrix for rotation from the right.\r\n * The vector of rotation axis may not be normalized.\r\n * @param angle The angle of rotation (degrees)\r\n * @param x The X coordinate of vector of rotation axis.\r\n * @param y The Y coordinate of vector of rotation axis.\r\n * @param z The Z coordinate of vector of rotation axis.\r\n * @return this\r\n */\r\nMatrix4.prototype.rotate = function(angle, x, y, z) {\r\n  return this.concat(new Matrix4().setRotate(angle, x, y, z));\r\n};\r\n\r\n/**\r\n * Set the viewing matrix.\r\n * @param eyeX, eyeY, eyeZ The position of the eye point.\r\n * @param centerX, centerY, centerZ The position of the reference point.\r\n * @param upX, upY, upZ The direction of the up vector.\r\n * @return this\r\n */\r\nMatrix4.prototype.setLookAt = function(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {\r\n  var e, fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;\r\n\r\n  fx = centerX - eyeX;\r\n  fy = centerY - eyeY;\r\n  fz = centerZ - eyeZ;\r\n\r\n  // Normalize f.\r\n  rlf = 1 / Math.sqrt(fx*fx + fy*fy + fz*fz);\r\n  fx *= rlf;\r\n  fy *= rlf;\r\n  fz *= rlf;\r\n\r\n  // Calculate cross product of f and up.\r\n  sx = fy * upZ - fz * upY;\r\n  sy = fz * upX - fx * upZ;\r\n  sz = fx * upY - fy * upX;\r\n\r\n  // Normalize s.\r\n  rls = 1 / Math.sqrt(sx*sx + sy*sy + sz*sz);\r\n  sx *= rls;\r\n  sy *= rls;\r\n  sz *= rls;\r\n\r\n  // Calculate cross product of s and f.\r\n  ux = sy * fz - sz * fy;\r\n  uy = sz * fx - sx * fz;\r\n  uz = sx * fy - sy * fx;\r\n\r\n  // Set to this.\r\n  e = this.elements;\r\n  e[0] = sx;\r\n  e[1] = ux;\r\n  e[2] = -fx;\r\n  e[3] = 0;\r\n\r\n  e[4] = sy;\r\n  e[5] = uy;\r\n  e[6] = -fy;\r\n  e[7] = 0;\r\n\r\n  e[8] = sz;\r\n  e[9] = uz;\r\n  e[10] = -fz;\r\n  e[11] = 0;\r\n\r\n  e[12] = 0;\r\n  e[13] = 0;\r\n  e[14] = 0;\r\n  e[15] = 1;\r\n\r\n  // Translate.\r\n  return this.translate(-eyeX, -eyeY, -eyeZ);\r\n};\r\n\r\n/**\r\n * Multiply the viewing matrix from the right.\r\n * @param eyeX, eyeY, eyeZ The position of the eye point.\r\n * @param centerX, centerY, centerZ The position of the reference point.\r\n * @param upX, upY, upZ The direction of the up vector.\r\n * @return this\r\n */\r\nMatrix4.prototype.lookAt = function(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {\r\n  return this.concat(new Matrix4().setLookAt(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ));\r\n};\r\n\r\n/**\r\n * Multiply the matrix for project vertex to plane from the right.\r\n * @param plane The array[A, B, C, D] of the equation of plane \"Ax + By + Cz + D = 0\".\r\n * @param light The array which stored coordinates of the light. if light[3]=0, treated as parallel light.\r\n * @return this\r\n */\r\nMatrix4.prototype.dropShadow = function(plane, light) {\r\n  var mat = new Matrix4();\r\n  var e = mat.elements;\r\n\r\n  var dot = plane[0] * light[0] + plane[1] * light[1] + plane[2] * light[2] + plane[3] * light[3];\r\n\r\n  e[ 0] = dot - light[0] * plane[0];\r\n  e[ 1] =     - light[1] * plane[0];\r\n  e[ 2] =     - light[2] * plane[0];\r\n  e[ 3] =     - light[3] * plane[0];\r\n\r\n  e[ 4] =     - light[0] * plane[1];\r\n  e[ 5] = dot - light[1] * plane[1];\r\n  e[ 6] =     - light[2] * plane[1];\r\n  e[ 7] =     - light[3] * plane[1];\r\n\r\n  e[ 8] =     - light[0] * plane[2];\r\n  e[ 9] =     - light[1] * plane[2];\r\n  e[10] = dot - light[2] * plane[2];\r\n  e[11] =     - light[3] * plane[2];\r\n\r\n  e[12] =     - light[0] * plane[3];\r\n  e[13] =     - light[1] * plane[3];\r\n  e[14] =     - light[2] * plane[3];\r\n  e[15] = dot - light[3] * plane[3];\r\n\r\n  return this.concat(mat);\r\n}\r\n\r\n/**\r\n * Multiply the matrix for project vertex to plane from the right.(Projected by parallel light.)\r\n * @param normX, normY, normZ The normal vector of the plane.(Not necessary to be normalized.)\r\n * @param planeX, planeY, planeZ The coordinate of arbitrary points on a plane.\r\n * @param lightX, lightY, lightZ The vector of the direction of light.(Not necessary to be normalized.)\r\n * @return this\r\n */\r\nMatrix4.prototype.dropShadowDirectionally = function(normX, normY, normZ, planeX, planeY, planeZ, lightX, lightY, lightZ) {\r\n  var a = planeX * normX + planeY * normY + planeZ * normZ;\r\n  return this.dropShadow([normX, normY, normZ, -a], [lightX, lightY, lightZ, 0]);\r\n};\r\n\r\n/**\r\n * Constructor of Vector3\r\n * If opt_src is specified, new vector is initialized by opt_src.\r\n * @param opt_src source vector(option)\r\n */\r\nvar Vector3 = function(opt_src) {\r\n  var v = new Float32Array(3);\r\n  if (opt_src && typeof opt_src === 'object') {\r\n    v[0] = opt_src[0]; v[1] = opt_src[1]; v[2] = opt_src[2];\r\n  } \r\n  this.elements = v;\r\n}\r\n\r\n/**\r\n  * Normalize.\r\n  * @return this\r\n  */\r\nVector3.prototype.normalize = function() {\r\n  var v = this.elements;\r\n  var c = v[0], d = v[1], e = v[2], g = Math.sqrt(c*c+d*d+e*e);\r\n  if(g){\r\n    if(g == 1)\r\n        return this;\r\n   } else {\r\n     v[0] = 0; v[1] = 0; v[2] = 0;\r\n     return this;\r\n   }\r\n   g = 1/g;\r\n   v[0] = c*g; v[1] = d*g; v[2] = e*g;\r\n   return this;\r\n};\r\n\r\n/**\r\n * Constructor of Vector4\r\n * If opt_src is specified, new vector is initialized by opt_src.\r\n * @param opt_src source vector(option)\r\n */\r\nvar Vector4 = function(opt_src) {\r\n  var v = new Float32Array(4);\r\n  if (opt_src && typeof opt_src === 'object') {\r\n    v[0] = opt_src[0]; v[1] = opt_src[1]; v[2] = opt_src[2]; v[3] = opt_src[3];\r\n  } \r\n  this.elements = v;\r\n}\r\n"},function(r,n,e){e(0)(e(23))},function(r,n){r.exports="\nvar VSHADER_SOURCE = 'attribute vec4 a_Position; \\n' +\n'attribute vec4 a_Color; \\n' +\n'uniform mat4 u_ViewMatrix; \\n' +\n'uniform mat4 u_ProjMatrix; \\n' +\n'uniform mat4 u_ModelMatrix; \\n' +\n// 'varying vec4 v_Color; \\n' +\n// ' attribute vec4 a_Normal; \\n' +\n// ' uniform vec3 u_LightColor; \\n' +\n// ' uniform vec3 u_LightDirection; \\n' +\n'attribute vec2 a_TexCoord; \\n' +\n'varying vec2 v_TexCoord; \\n' +\n'void main() { \\n' +\n' gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position; \\n' +\n' v_TexCoord = a_TexCoord; \\n' +\n// 'vec3 normal = normalize(vec3(a_Normal)); \\n' +\n// 'float nDotL = max(dot(u_LightDirection, normal), 0.0); \\n' +\n// 'vec3 diffuse = u_LightColor * vec3(a_Color) * nDotL; \\n' +\n// // ' v_Color = a_Color; \\n' +\n// 'v_Color = vec4(diffuse, a_Color.a); \\n' +\n'} \\n';\n\nvar FSHADER_SOURCE = 'precision mediump float; \\n' +\n'uniform sampler2D u_Sampler0; \\n' +\n'varying vec2 v_TexCoord; \\n' +\n'void main() { \\n' +\n' vec4 color0 = texture2D(u_Sampler0, v_TexCoord); \\n' +\n' gl_FragColor = color0; \\n' +\n'} \\n';"},function(r,n,e){e(0)(e(25))},function(r,n){r.exports="\n// var vertices = new Float32Array([\n//     -0.5,  0.5,\n//     -0.5, -0.5,\n//      0.5,  0.5,\n//      0.5, -0.5,\n//     ]);\n\nvar TexCoords = new Float32Array([\n  0.0, 1.0,  0.0, 0.0,   1.0, 0.0,   1.0, 1.0,\n  0.0, 1.0,  0.0, 0.0,   1.0, 0.0,   1.0, 1.0,\n  1.0, 1.0,  0.0, 1.0,   0.0, 0.0,   1.0, 0.0,\n  1.0, 1.0,  0.0, 1.0,   0.0, 0.0,   1.0, 0.0,\n  0.0, 0.0,   1.0, 0.0,   1.0, 1.0,  0.0, 1.0\n    ]);\n\n  var vertices = new Float32Array([   // Coordinates\n     // 1.0, 1.0, 1.0,  -1.0, 1.0, 1.0,  -1.0,-1.0, 1.0,   1.0,-1.0, 1.0, // v0-v1-v2-v3 front\n     1.0, 1.0, 3.0,   1.0,-1.0, 3.0,   1.0,-1.0,-3.0,   1.0, 1.0,-3.0, // v0-v3-v4-v5 right\n     1.0, 1.0, 3.0,   1.0, 1.0,-3.0,  -1.0, 1.0,-3.0,  -1.0, 1.0, 3.0, // v0-v5-v6-v1 up\n    -1.0, 1.0, 3.0,  -1.0, 1.0,-3.0,  -1.0,-1.0,-3.0,  -1.0,-1.0, 3.0, // v1-v6-v7-v2 left\n    -1.0,-1.0,-3.0,   1.0,-1.0,-3.0,   1.0,-1.0, 3.0,  -1.0,-1.0, 3.0, // v7-v4-v3-v2 down\n     1.0,-1.0,-3.0,  -1.0,-1.0,-3.0,  -1.0, 1.0,-3.0,   1.0, 1.0,-3.0  // v4-v7-v6-v5 back\n  ]);\n\n\n //  var colors = new Float32Array([    // Colors\n //    // 1, 0, 0,   1, 0, 0,   1, 0, 0,  1, 0, 0,     // v0-v1-v2-v3 front\n //    1, 0, 0,   1, 0, 0,   1, 0, 0,  1, 0, 0,     // v0-v3-v4-v5 right\n //    1, 1, 0,   1, 0, 0,   1, 0, 0,  1, 0, 0,     // v0-v5-v6-v1 up\n //    1, 0, 0,   1, 1, 1,   1, 0, 0,  1, 0, 0,     // v1-v6-v7-v2 left\n //    1, 0, 0,   1, 0, 0,   1, 1, 1,  1, 0, 0,     // v7-v4-v3-v2 down\n //    1, 0, 0,   1, 0, 0,   1, 0, 0,  1, 1, 1ã€€    // v4-v7-v6-v5 back\n // ]);\n\n\n  var normals = new Float32Array([    // Normal\n    // 0.0, 0.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0, 1.0,  // v0-v1-v2-v3 front\n    1.0, 0.0, 0.0,   1.0, 0.0, 0.0,   1.0, 0.0, 0.0,   1.0, 0.0, 0.0,  // v0-v3-v4-v5 right\n    0.0, 1.0, 0.0,   0.0, 1.0, 0.0,   0.0, 1.0, 0.0,   0.0, 1.0, 0.0,  // v0-v5-v6-v1 up\n   1.0, 0.0, 0.0,  1.0, 0.0, 0.0,  1.0, 0.0, 0.0,  1.0, 0.0, 0.0,  // v1-v6-v7-v2 left\n    0.0,1.0, 0.0,   0.0,1.0, 0.0,   0.0,1.0, 0.0,   0.0,1.0, 0.0,  // v7-v4-v3-v2 down\n    0.0, 0.0,1.0,   0.0, 0.0,1.0,   0.0, 0.0,1.0,   0.0, 0.0,1.0   // v4-v7-v6-v5 back\n  ]);\n\n\n  // Indices of the vertices\n  var indices = new Uint8Array([\n     0, 1, 2,   0, 2, 3,    // right\n     4, 5, 6,   4, 6, 7,    // up\n     8, 9,10,   8,10,11,    // left\n    12,13,14,  12,14,15,    // down\n    16,17,18,  16,18,19    // back\n    // 20,21,22,  20,22,23     // back front\n ]);"}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzIiwid2VicGFjazovLy8uL3NyYy91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL2N1b24tdXRpbHMuanM/NzQwOCIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL2N1b24tdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9jdW9uLW1hdHJpeC5qcz9jZGY4Iiwid2VicGFjazovLy8uL3NyYy9saWIvY3Vvbi1tYXRyaXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnNvdXJjZS5qcz82MTc2Iiwid2VicGFjazovLy8uL3NyYy9zaGFkZXJzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlcnRpY2VzLmpzP2Q5NDciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlcnRpY2VzLmpzIl0sIm5hbWVzIjpbImluc3RhbGxlZE1vZHVsZXMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibW9kdWxlSWQiLCJleHBvcnRzIiwibW9kdWxlIiwiaSIsImwiLCJtb2R1bGVzIiwiY2FsbCIsIm0iLCJjIiwiZCIsIm5hbWUiLCJnZXR0ZXIiLCJvIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiciIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwidmFsdWUiLCJ0IiwibW9kZSIsIl9fZXNNb2R1bGUiLCJucyIsImNyZWF0ZSIsImtleSIsImJpbmQiLCJuIiwib2JqZWN0IiwicHJvcGVydHkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsInAiLCJzIiwic3JjIiwibG9nIiwiZXJyb3IiLCJjb25zb2xlIiwiZXhlY1NjcmlwdCIsImF0dGFjaEV2ZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2YWwiLCJfX3dlYnBhY2tfZXhwb3J0c19fIl0sIm1hcHBpbmdzIjoiYUFDQSxJQUFBQSxLQUdBLFNBQUFDLEVBQUFDLEdBR0EsR0FBQUYsRUFBQUUsR0FDQSxPQUFBRixFQUFBRSxHQUFBQyxRQUdBLElBQUFDLEVBQUFKLEVBQUFFLElBQ0FHLEVBQUFILEVBQ0FJLEdBQUEsRUFDQUgsWUFVQSxPQU5BSSxFQUFBTCxHQUFBTSxLQUFBSixFQUFBRCxRQUFBQyxJQUFBRCxRQUFBRixHQUdBRyxFQUFBRSxHQUFBLEVBR0FGLEVBQUFELFFBS0FGLEVBQUFRLEVBQUFGLEVBR0FOLEVBQUFTLEVBQUFWLEVBR0FDLEVBQUFVLEVBQUEsU0FBQVIsRUFBQVMsRUFBQUMsR0FDQVosRUFBQWEsRUFBQVgsRUFBQVMsSUFDQUcsT0FBQUMsZUFBQWIsRUFBQVMsR0FBMENLLFlBQUEsRUFBQUMsSUFBQUwsS0FLMUNaLEVBQUFrQixFQUFBLFNBQUFoQixHQUNBLG9CQUFBaUIsZUFBQUMsYUFDQU4sT0FBQUMsZUFBQWIsRUFBQWlCLE9BQUFDLGFBQXdEQyxNQUFBLFdBRXhEUCxPQUFBQyxlQUFBYixFQUFBLGNBQWlEbUIsT0FBQSxLQVFqRHJCLEVBQUFzQixFQUFBLFNBQUFELEVBQUFFLEdBRUEsR0FEQSxFQUFBQSxJQUFBRixFQUFBckIsRUFBQXFCLElBQ0EsRUFBQUUsRUFBQSxPQUFBRixFQUNBLEtBQUFFLEdBQUEsaUJBQUFGLFFBQUFHLFdBQUEsT0FBQUgsRUFDQSxJQUFBSSxFQUFBWCxPQUFBWSxPQUFBLE1BR0EsR0FGQTFCLEVBQUFrQixFQUFBTyxHQUNBWCxPQUFBQyxlQUFBVSxFQUFBLFdBQXlDVCxZQUFBLEVBQUFLLFVBQ3pDLEVBQUFFLEdBQUEsaUJBQUFGLEVBQUEsUUFBQU0sS0FBQU4sRUFBQXJCLEVBQUFVLEVBQUFlLEVBQUFFLEVBQUEsU0FBQUEsR0FBZ0gsT0FBQU4sRUFBQU0sSUFBcUJDLEtBQUEsS0FBQUQsSUFDckksT0FBQUYsR0FJQXpCLEVBQUE2QixFQUFBLFNBQUExQixHQUNBLElBQUFTLEVBQUFULEtBQUFxQixXQUNBLFdBQTJCLE9BQUFyQixFQUFBLFNBQzNCLFdBQWlDLE9BQUFBLEdBRWpDLE9BREFILEVBQUFVLEVBQUFFLEVBQUEsSUFBQUEsR0FDQUEsR0FJQVosRUFBQWEsRUFBQSxTQUFBaUIsRUFBQUMsR0FBc0QsT0FBQWpCLE9BQUFrQixVQUFBQyxlQUFBMUIsS0FBQXVCLEVBQUFDLElBR3REL0IsRUFBQWtDLEVBQUEsR0FJQWxDLElBQUFtQyxFQUFBLG9CQzlFQWhDLEVBQUFELFFBQUEsU0FBQWtDLEdBQ0EsU0FBQUMsRUFBQUMsR0FDQSxvQkFBQUMsVUFDQUEsUUFBQUQsT0FBQUMsUUFBQUYsS0FBQSxrQkFBQUMsR0FRQSxJQUNBLG9CQUFBRSxZQUpBLG9CQUFBQyxhQUFBLG9CQUFBQyxpQkFLQUYsV0FBQUosR0FDRyxvQkFBQU8sS0FDSEEsS0FBQXBDLEtBQUEsS0FBQTZCLEdBRUFDLEVBQUEseUNBRUUsTUFBQUMsR0FDRkQsRUFBQUMsbURDeEJBdEMsRUFBQWtCLEVBQUEwQixHQUFBNUMsRUFBQSxJQUFBQSxFQUFBLElBQUFBLEVBQUEsSUFBQUEsRUFBQSxxQkNBQUEsRUFBUSxFQUFSQSxDQUF1RkEsRUFBUSxvQkNBL0ZHLEVBQUFELFFBQUEsMDJHQ0FBRixFQUFRLEVBQVJBLENBQXVGQSxFQUFRLG9CQ0EvRkcsRUFBQUQsUUFBQSxzN3RCQ0FBRixFQUFRLEVBQVJBLENBQXVGQSxFQUFRLG9CQ0EvRkcsRUFBQUQsUUFBQSw4bENDQUFGLEVBQVEsRUFBUkEsQ0FBdUZBLEVBQVEsb0JDQS9GRyxFQUFBRCxRQUFBIiwiZmlsZSI6InV0aWxzLmJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxNyk7XG4iLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzcmMpIHtcblx0ZnVuY3Rpb24gbG9nKGVycm9yKSB7XG5cdFx0KHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKVxuXHRcdCYmIChjb25zb2xlLmVycm9yIHx8IGNvbnNvbGUubG9nKShcIltTY3JpcHQgTG9hZGVyXVwiLCBlcnJvcik7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgSUUgPTwgOFxuXHRmdW5jdGlvbiBpc0lFKCkge1xuXHRcdHJldHVybiB0eXBlb2YgYXR0YWNoRXZlbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgPT09IFwidW5kZWZpbmVkXCI7XG5cdH1cblxuXHR0cnkge1xuXHRcdGlmICh0eXBlb2YgZXhlY1NjcmlwdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpc0lFKCkpIHtcblx0XHRcdGV4ZWNTY3JpcHQoc3JjKTtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBldmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRldmFsLmNhbGwobnVsbCwgc3JjKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bG9nKFwiRXZhbEVycm9yOiBObyBldmFsIGZ1bmN0aW9uIGF2YWlsYWJsZVwiKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0bG9nKGVycm9yKTtcblx0fVxufVxuIiwiaW1wb3J0IGV4ZWMgZnJvbSAnc2NyaXB0LWxvYWRlciEuL2xpYi9jdW9uLXV0aWxzLmpzJztcbmltcG9ydCBleGVjMSBmcm9tICdzY3JpcHQtbG9hZGVyIS4vbGliL2N1b24tbWF0cml4LmpzJztcbmltcG9ydCBleGVjMiBmcm9tICdzY3JpcHQtbG9hZGVyIS4vc2hhZGVyc291cmNlLmpzJztcbmltcG9ydCBleGVjMyBmcm9tICdzY3JpcHQtbG9hZGVyIS4vdmVydGljZXMuanMnO1xuXG4iLCJyZXF1aXJlKFwiISEvc2F2ZXByb2ovTU1Ed2ViL3dlYmdsTU1EL21tZHRlc3Qvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9zYXZlcHJvai9NTUR3ZWIvd2ViZ2xNTUQvbW1kdGVzdC9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvc2F2ZXByb2ovTU1Ed2ViL3dlYmdsTU1EL21tZHRlc3Qvc3JjL2xpYi9jdW9uLXV0aWxzLmpzXCIpKSIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBjdW9uLXV0aWxzLmpzIChjKSAyMDEyIGthbmRhIGFuZCBtYXRzdWRhXFxyXFxuLyoqXFxyXFxuICogQ3JlYXRlIGEgcHJvZ3JhbSBvYmplY3QgYW5kIG1ha2UgY3VycmVudFxcclxcbiAqIEBwYXJhbSBnbCBHTCBjb250ZXh0XFxyXFxuICogQHBhcmFtIHZzaGFkZXIgYSB2ZXJ0ZXggc2hhZGVyIHByb2dyYW0gKHN0cmluZylcXHJcXG4gKiBAcGFyYW0gZnNoYWRlciBhIGZyYWdtZW50IHNoYWRlciBwcm9ncmFtIChzdHJpbmcpXFxyXFxuICogQHJldHVybiB0cnVlLCBpZiB0aGUgcHJvZ3JhbSBvYmplY3Qgd2FzIGNyZWF0ZWQgYW5kIHN1Y2Nlc3NmdWxseSBtYWRlIGN1cnJlbnQgXFxyXFxuICovXFxyXFxuZnVuY3Rpb24gaW5pdFNoYWRlcnMoZ2wsIHZzaGFkZXIsIGZzaGFkZXIpIHtcXHJcXG4gIHZhciBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbShnbCwgdnNoYWRlciwgZnNoYWRlcik7XFxyXFxuICBpZiAoIXByb2dyYW0pIHtcXHJcXG4gICAgY29uc29sZS5sb2coJ0ZhaWxlZCB0byBjcmVhdGUgcHJvZ3JhbScpO1xcclxcbiAgICByZXR1cm4gZmFsc2U7XFxyXFxuICB9XFxyXFxuXFxyXFxuICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xcclxcbiAgZ2wucHJvZ3JhbSA9IHByb2dyYW07XFxyXFxuXFxyXFxuICByZXR1cm4gdHJ1ZTtcXHJcXG59XFxyXFxuXFxyXFxuLyoqXFxyXFxuICogQ3JlYXRlIHRoZSBsaW5rZWQgcHJvZ3JhbSBvYmplY3RcXHJcXG4gKiBAcGFyYW0gZ2wgR0wgY29udGV4dFxcclxcbiAqIEBwYXJhbSB2c2hhZGVyIGEgdmVydGV4IHNoYWRlciBwcm9ncmFtIChzdHJpbmcpXFxyXFxuICogQHBhcmFtIGZzaGFkZXIgYSBmcmFnbWVudCBzaGFkZXIgcHJvZ3JhbSAoc3RyaW5nKVxcclxcbiAqIEByZXR1cm4gY3JlYXRlZCBwcm9ncmFtIG9iamVjdCwgb3IgbnVsbCBpZiB0aGUgY3JlYXRpb24gaGFzIGZhaWxlZFxcclxcbiAqL1xcclxcbmZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oZ2wsIHZzaGFkZXIsIGZzaGFkZXIpIHtcXHJcXG4gIC8vIENyZWF0ZSBzaGFkZXIgb2JqZWN0XFxyXFxuICB2YXIgdmVydGV4U2hhZGVyID0gbG9hZFNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdnNoYWRlcik7XFxyXFxuICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBsb2FkU2hhZGVyKGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZzaGFkZXIpO1xcclxcbiAgaWYgKCF2ZXJ0ZXhTaGFkZXIgfHwgIWZyYWdtZW50U2hhZGVyKSB7XFxyXFxuICAgIHJldHVybiBudWxsO1xcclxcbiAgfVxcclxcblxcclxcbiAgLy8gQ3JlYXRlIGEgcHJvZ3JhbSBvYmplY3RcXHJcXG4gIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xcclxcbiAgaWYgKCFwcm9ncmFtKSB7XFxyXFxuICAgIHJldHVybiBudWxsO1xcclxcbiAgfVxcclxcblxcclxcbiAgLy8gQXR0YWNoIHRoZSBzaGFkZXIgb2JqZWN0c1xcclxcbiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XFxyXFxuICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xcclxcblxcclxcbiAgLy8gTGluayB0aGUgcHJvZ3JhbSBvYmplY3RcXHJcXG4gIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xcclxcblxcclxcbiAgLy8gQ2hlY2sgdGhlIHJlc3VsdCBvZiBsaW5raW5nXFxyXFxuICB2YXIgbGlua2VkID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUyk7XFxyXFxuICBpZiAoIWxpbmtlZCkge1xcclxcbiAgICB2YXIgZXJyb3IgPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKTtcXHJcXG4gICAgY29uc29sZS5sb2coJ0ZhaWxlZCB0byBsaW5rIHByb2dyYW06ICcgKyBlcnJvcik7XFxyXFxuICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XFxyXFxuICAgIGdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XFxyXFxuICAgIGdsLmRlbGV0ZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xcclxcbiAgICByZXR1cm4gbnVsbDtcXHJcXG4gIH1cXHJcXG4gIHJldHVybiBwcm9ncmFtO1xcclxcbn1cXHJcXG5cXHJcXG4vKipcXHJcXG4gKiBDcmVhdGUgYSBzaGFkZXIgb2JqZWN0XFxyXFxuICogQHBhcmFtIGdsIEdMIGNvbnRleHRcXHJcXG4gKiBAcGFyYW0gdHlwZSB0aGUgdHlwZSBvZiB0aGUgc2hhZGVyIG9iamVjdCB0byBiZSBjcmVhdGVkXFxyXFxuICogQHBhcmFtIHNvdXJjZSBzaGFkZXIgcHJvZ3JhbSAoc3RyaW5nKVxcclxcbiAqIEByZXR1cm4gY3JlYXRlZCBzaGFkZXIgb2JqZWN0LCBvciBudWxsIGlmIHRoZSBjcmVhdGlvbiBoYXMgZmFpbGVkLlxcclxcbiAqL1xcclxcbmZ1bmN0aW9uIGxvYWRTaGFkZXIoZ2wsIHR5cGUsIHNvdXJjZSkge1xcclxcbiAgLy8gQ3JlYXRlIHNoYWRlciBvYmplY3RcXHJcXG4gIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XFxyXFxuICBpZiAoc2hhZGVyID09IG51bGwpIHtcXHJcXG4gICAgY29uc29sZS5sb2coJ3VuYWJsZSB0byBjcmVhdGUgc2hhZGVyJyk7XFxyXFxuICAgIHJldHVybiBudWxsO1xcclxcbiAgfVxcclxcblxcclxcbiAgLy8gU2V0IHRoZSBzaGFkZXIgcHJvZ3JhbVxcclxcbiAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlKTtcXHJcXG5cXHJcXG4gIC8vIENvbXBpbGUgdGhlIHNoYWRlclxcclxcbiAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xcclxcblxcclxcbiAgLy8gQ2hlY2sgdGhlIHJlc3VsdCBvZiBjb21waWxhdGlvblxcclxcbiAgdmFyIGNvbXBpbGVkID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpO1xcclxcbiAgaWYgKCFjb21waWxlZCkge1xcclxcbiAgICB2YXIgZXJyb3IgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcik7XFxyXFxuICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgdG8gY29tcGlsZSBzaGFkZXI6ICcgKyBlcnJvcik7XFxyXFxuICAgIGdsLmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xcclxcbiAgICByZXR1cm4gbnVsbDtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIHJldHVybiBzaGFkZXI7XFxyXFxufVxcclxcblxcclxcbi8qKiBcXHJcXG4gKiBJbml0aWFsaXplIGFuZCBnZXQgdGhlIHJlbmRlcmluZyBmb3IgV2ViR0xcXHJcXG4gKiBAcGFyYW0gY2FudmFzIDxjYXZuYXM+IGVsZW1lbnRcXHJcXG4gKiBAcGFyYW0gb3B0X2RlYnVnIGZsYWcgdG8gaW5pdGlhbGl6ZSB0aGUgY29udGV4dCBmb3IgZGVidWdnaW5nXFxyXFxuICogQHJldHVybiB0aGUgcmVuZGVyaW5nIGNvbnRleHQgZm9yIFdlYkdMXFxyXFxuICovXFxyXFxuZnVuY3Rpb24gZ2V0V2ViR0xDb250ZXh0KGNhbnZhcywgb3B0X2RlYnVnKSB7XFxyXFxuICAvLyBHZXQgdGhlIHJlbmRlcmluZyBjb250ZXh0IGZvciBXZWJHTFxcclxcbiAgdmFyIGdsID0gV2ViR0xVdGlscy5zZXR1cFdlYkdMKGNhbnZhcyk7XFxyXFxuICBpZiAoIWdsKSByZXR1cm4gbnVsbDtcXHJcXG5cXHJcXG4gIC8vIGlmIG9wdF9kZWJ1ZyBpcyBleHBsaWNpdGx5IGZhbHNlLCBjcmVhdGUgdGhlIGNvbnRleHQgZm9yIGRlYnVnZ2luZ1xcclxcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyIHx8IG9wdF9kZWJ1Zykge1xcclxcbiAgICBnbCA9IFdlYkdMRGVidWdVdGlscy5tYWtlRGVidWdDb250ZXh0KGdsKTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIHJldHVybiBnbDtcXHJcXG59XFxyXFxuXCIiLCJyZXF1aXJlKFwiISEvc2F2ZXByb2ovTU1Ed2ViL3dlYmdsTU1EL21tZHRlc3Qvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9zYXZlcHJvai9NTUR3ZWIvd2ViZ2xNTUQvbW1kdGVzdC9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvc2F2ZXByb2ovTU1Ed2ViL3dlYmdsTU1EL21tZHRlc3Qvc3JjL2xpYi9jdW9uLW1hdHJpeC5qc1wiKSkiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gY3Vvbi1tYXRyaXguanMgKGMpIDIwMTIga2FuZGEgYW5kIG1hdHN1ZGFcXHJcXG4vKiogXFxyXFxuICogVGhpcyBpcyBhIGNsYXNzIHRyZWF0aW5nIDR4NCBtYXRyaXguXFxyXFxuICogVGhpcyBjbGFzcyBjb250YWlucyB0aGUgZnVuY3Rpb24gdGhhdCBpcyBlcXVpdmFsZW50IHRvIE9wZW5HTCBtYXRyaXggc3RhY2suXFxyXFxuICogVGhlIG1hdHJpeCBhZnRlciBjb252ZXJzaW9uIGlzIGNhbGN1bGF0ZWQgYnkgbXVsdGlwbHlpbmcgYSBjb252ZXJzaW9uIG1hdHJpeCBmcm9tIHRoZSByaWdodC5cXHJcXG4gKiBUaGUgbWF0cml4IGlzIHJlcGxhY2VkIGJ5IHRoZSBjYWxjdWxhdGVkIHJlc3VsdC5cXHJcXG4gKi9cXHJcXG5cXHJcXG4vKipcXHJcXG4gKiBDb25zdHJ1Y3RvciBvZiBNYXRyaXg0XFxyXFxuICogSWYgb3B0X3NyYyBpcyBzcGVjaWZpZWQsIG5ldyBtYXRyaXggaXMgaW5pdGlhbGl6ZWQgYnkgb3B0X3NyYy5cXHJcXG4gKiBPdGhlcndpc2UsIG5ldyBtYXRyaXggaXMgaW5pdGlhbGl6ZWQgYnkgaWRlbnRpdHkgbWF0cml4LlxcclxcbiAqIEBwYXJhbSBvcHRfc3JjIHNvdXJjZSBtYXRyaXgob3B0aW9uKVxcclxcbiAqL1xcclxcbnZhciBNYXRyaXg0ID0gZnVuY3Rpb24ob3B0X3NyYykge1xcclxcbiAgdmFyIGksIHMsIGQ7XFxyXFxuICBpZiAob3B0X3NyYyAmJiB0eXBlb2Ygb3B0X3NyYyA9PT0gJ29iamVjdCcgJiYgb3B0X3NyYy5oYXNPd25Qcm9wZXJ0eSgnZWxlbWVudHMnKSkge1xcclxcbiAgICBzID0gb3B0X3NyYy5lbGVtZW50cztcXHJcXG4gICAgZCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xcclxcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTY7ICsraSkge1xcclxcbiAgICAgIGRbaV0gPSBzW2ldO1xcclxcbiAgICB9XFxyXFxuICAgIHRoaXMuZWxlbWVudHMgPSBkO1xcclxcbiAgfSBlbHNlIHtcXHJcXG4gICAgdGhpcy5lbGVtZW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoWzEsMCwwLDAsIDAsMSwwLDAsIDAsMCwxLDAsIDAsMCwwLDFdKTtcXHJcXG4gIH1cXHJcXG59O1xcclxcblxcclxcbi8qKlxcclxcbiAqIFNldCB0aGUgaWRlbnRpdHkgbWF0cml4LlxcclxcbiAqIEByZXR1cm4gdGhpc1xcclxcbiAqL1xcclxcbk1hdHJpeDQucHJvdG90eXBlLnNldElkZW50aXR5ID0gZnVuY3Rpb24oKSB7XFxyXFxuICB2YXIgZSA9IHRoaXMuZWxlbWVudHM7XFxyXFxuICBlWzBdID0gMTsgICBlWzRdID0gMDsgICBlWzhdICA9IDA7ICAgZVsxMl0gPSAwO1xcclxcbiAgZVsxXSA9IDA7ICAgZVs1XSA9IDE7ICAgZVs5XSAgPSAwOyAgIGVbMTNdID0gMDtcXHJcXG4gIGVbMl0gPSAwOyAgIGVbNl0gPSAwOyAgIGVbMTBdID0gMTsgICBlWzE0XSA9IDA7XFxyXFxuICBlWzNdID0gMDsgICBlWzddID0gMDsgICBlWzExXSA9IDA7ICAgZVsxNV0gPSAxO1xcclxcbiAgcmV0dXJuIHRoaXM7XFxyXFxufTtcXHJcXG5cXHJcXG4vKipcXHJcXG4gKiBDb3B5IG1hdHJpeC5cXHJcXG4gKiBAcGFyYW0gc3JjIHNvdXJjZSBtYXRyaXhcXHJcXG4gKiBAcmV0dXJuIHRoaXNcXHJcXG4gKi9cXHJcXG5NYXRyaXg0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihzcmMpIHtcXHJcXG4gIHZhciBpLCBzLCBkO1xcclxcblxcclxcbiAgcyA9IHNyYy5lbGVtZW50cztcXHJcXG4gIGQgPSB0aGlzLmVsZW1lbnRzO1xcclxcblxcclxcbiAgaWYgKHMgPT09IGQpIHtcXHJcXG4gICAgcmV0dXJuO1xcclxcbiAgfVxcclxcbiAgICBcXHJcXG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgKytpKSB7XFxyXFxuICAgIGRbaV0gPSBzW2ldO1xcclxcbiAgfVxcclxcblxcclxcbiAgcmV0dXJuIHRoaXM7XFxyXFxufTtcXHJcXG5cXHJcXG4vKipcXHJcXG4gKiBNdWx0aXBseSB0aGUgbWF0cml4IGZyb20gdGhlIHJpZ2h0LlxcclxcbiAqIEBwYXJhbSBvdGhlciBUaGUgbXVsdGlwbHkgbWF0cml4XFxyXFxuICogQHJldHVybiB0aGlzXFxyXFxuICovXFxyXFxuTWF0cml4NC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24ob3RoZXIpIHtcXHJcXG4gIHZhciBpLCBlLCBhLCBiLCBhaTAsIGFpMSwgYWkyLCBhaTM7XFxyXFxuICBcXHJcXG4gIC8vIENhbGN1bGF0ZSBlID0gYSAqIGJcXHJcXG4gIGUgPSB0aGlzLmVsZW1lbnRzO1xcclxcbiAgYSA9IHRoaXMuZWxlbWVudHM7XFxyXFxuICBiID0gb3RoZXIuZWxlbWVudHM7XFxyXFxuICBcXHJcXG4gIC8vIElmIGUgZXF1YWxzIGIsIGNvcHkgYiB0byB0ZW1wb3JhcnkgbWF0cml4LlxcclxcbiAgaWYgKGUgPT09IGIpIHtcXHJcXG4gICAgYiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xcclxcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTY7ICsraSkge1xcclxcbiAgICAgIGJbaV0gPSBlW2ldO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcXHJcXG4gICAgYWkwPWFbaV07ICBhaTE9YVtpKzRdOyAgYWkyPWFbaSs4XTsgIGFpMz1hW2krMTJdO1xcclxcbiAgICBlW2ldICAgID0gYWkwICogYlswXSAgKyBhaTEgKiBiWzFdICArIGFpMiAqIGJbMl0gICsgYWkzICogYlszXTtcXHJcXG4gICAgZVtpKzRdICA9IGFpMCAqIGJbNF0gICsgYWkxICogYls1XSAgKyBhaTIgKiBiWzZdICArIGFpMyAqIGJbN107XFxyXFxuICAgIGVbaSs4XSAgPSBhaTAgKiBiWzhdICArIGFpMSAqIGJbOV0gICsgYWkyICogYlsxMF0gKyBhaTMgKiBiWzExXTtcXHJcXG4gICAgZVtpKzEyXSA9IGFpMCAqIGJbMTJdICsgYWkxICogYlsxM10gKyBhaTIgKiBiWzE0XSArIGFpMyAqIGJbMTVdO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICByZXR1cm4gdGhpcztcXHJcXG59O1xcclxcbk1hdHJpeDQucHJvdG90eXBlLm11bHRpcGx5ID0gTWF0cml4NC5wcm90b3R5cGUuY29uY2F0O1xcclxcblxcclxcbi8qKlxcclxcbiAqIE11bHRpcGx5IHRoZSB0aHJlZS1kaW1lbnNpb25hbCB2ZWN0b3IuXFxyXFxuICogQHBhcmFtIHBvcyAgVGhlIG11bHRpcGx5IHZlY3RvclxcclxcbiAqIEByZXR1cm4gVGhlIHJlc3VsdCBvZiBtdWx0aXBsaWNhdGlvbihGbG9hdDMyQXJyYXkpXFxyXFxuICovXFxyXFxuTWF0cml4NC5wcm90b3R5cGUubXVsdGlwbHlWZWN0b3IzID0gZnVuY3Rpb24ocG9zKSB7XFxyXFxuICB2YXIgZSA9IHRoaXMuZWxlbWVudHM7XFxyXFxuICB2YXIgcCA9IHBvcy5lbGVtZW50cztcXHJcXG4gIHZhciB2ID0gbmV3IFZlY3RvcjMoKTtcXHJcXG4gIHZhciByZXN1bHQgPSB2LmVsZW1lbnRzO1xcclxcblxcclxcbiAgcmVzdWx0WzBdID0gcFswXSAqIGVbMF0gKyBwWzFdICogZVs0XSArIHBbMl0gKiBlWyA4XSArIGVbMTFdO1xcclxcbiAgcmVzdWx0WzFdID0gcFswXSAqIGVbMV0gKyBwWzFdICogZVs1XSArIHBbMl0gKiBlWyA5XSArIGVbMTJdO1xcclxcbiAgcmVzdWx0WzJdID0gcFswXSAqIGVbMl0gKyBwWzFdICogZVs2XSArIHBbMl0gKiBlWzEwXSArIGVbMTNdO1xcclxcblxcclxcbiAgcmV0dXJuIHY7XFxyXFxufTtcXHJcXG5cXHJcXG4vKipcXHJcXG4gKiBNdWx0aXBseSB0aGUgZm91ci1kaW1lbnNpb25hbCB2ZWN0b3IuXFxyXFxuICogQHBhcmFtIHBvcyAgVGhlIG11bHRpcGx5IHZlY3RvclxcclxcbiAqIEByZXR1cm4gVGhlIHJlc3VsdCBvZiBtdWx0aXBsaWNhdGlvbihGbG9hdDMyQXJyYXkpXFxyXFxuICovXFxyXFxuTWF0cml4NC5wcm90b3R5cGUubXVsdGlwbHlWZWN0b3I0ID0gZnVuY3Rpb24ocG9zKSB7XFxyXFxuICB2YXIgZSA9IHRoaXMuZWxlbWVudHM7XFxyXFxuICB2YXIgcCA9IHBvcy5lbGVtZW50cztcXHJcXG4gIHZhciB2ID0gbmV3IFZlY3RvcjQoKTtcXHJcXG4gIHZhciByZXN1bHQgPSB2LmVsZW1lbnRzO1xcclxcblxcclxcbiAgcmVzdWx0WzBdID0gcFswXSAqIGVbMF0gKyBwWzFdICogZVs0XSArIHBbMl0gKiBlWyA4XSArIHBbM10gKiBlWzEyXTtcXHJcXG4gIHJlc3VsdFsxXSA9IHBbMF0gKiBlWzFdICsgcFsxXSAqIGVbNV0gKyBwWzJdICogZVsgOV0gKyBwWzNdICogZVsxM107XFxyXFxuICByZXN1bHRbMl0gPSBwWzBdICogZVsyXSArIHBbMV0gKiBlWzZdICsgcFsyXSAqIGVbMTBdICsgcFszXSAqIGVbMTRdO1xcclxcbiAgcmVzdWx0WzNdID0gcFswXSAqIGVbM10gKyBwWzFdICogZVs3XSArIHBbMl0gKiBlWzExXSArIHBbM10gKiBlWzE1XTtcXHJcXG5cXHJcXG4gIHJldHVybiB2O1xcclxcbn07XFxyXFxuXFxyXFxuLyoqXFxyXFxuICogVHJhbnNwb3NlIHRoZSBtYXRyaXguXFxyXFxuICogQHJldHVybiB0aGlzXFxyXFxuICovXFxyXFxuTWF0cml4NC5wcm90b3R5cGUudHJhbnNwb3NlID0gZnVuY3Rpb24oKSB7XFxyXFxuICB2YXIgZSwgdDtcXHJcXG5cXHJcXG4gIGUgPSB0aGlzLmVsZW1lbnRzO1xcclxcblxcclxcbiAgdCA9IGVbIDFdOyAgZVsgMV0gPSBlWyA0XTsgIGVbIDRdID0gdDtcXHJcXG4gIHQgPSBlWyAyXTsgIGVbIDJdID0gZVsgOF07ICBlWyA4XSA9IHQ7XFxyXFxuICB0ID0gZVsgM107ICBlWyAzXSA9IGVbMTJdOyAgZVsxMl0gPSB0O1xcclxcbiAgdCA9IGVbIDZdOyAgZVsgNl0gPSBlWyA5XTsgIGVbIDldID0gdDtcXHJcXG4gIHQgPSBlWyA3XTsgIGVbIDddID0gZVsxM107ICBlWzEzXSA9IHQ7XFxyXFxuICB0ID0gZVsxMV07ICBlWzExXSA9IGVbMTRdOyAgZVsxNF0gPSB0O1xcclxcblxcclxcbiAgcmV0dXJuIHRoaXM7XFxyXFxufTtcXHJcXG5cXHJcXG4vKipcXHJcXG4gKiBDYWxjdWxhdGUgdGhlIGludmVyc2UgbWF0cml4IG9mIHNwZWNpZmllZCBtYXRyaXgsIGFuZCBzZXQgdG8gdGhpcy5cXHJcXG4gKiBAcGFyYW0gb3RoZXIgVGhlIHNvdXJjZSBtYXRyaXhcXHJcXG4gKiBAcmV0dXJuIHRoaXNcXHJcXG4gKi9cXHJcXG5NYXRyaXg0LnByb3RvdHlwZS5zZXRJbnZlcnNlT2YgPSBmdW5jdGlvbihvdGhlcikge1xcclxcbiAgdmFyIGksIHMsIGQsIGludiwgZGV0O1xcclxcblxcclxcbiAgcyA9IG90aGVyLmVsZW1lbnRzO1xcclxcbiAgZCA9IHRoaXMuZWxlbWVudHM7XFxyXFxuICBpbnYgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcXHJcXG5cXHJcXG4gIGludlswXSAgPSAgIHNbNV0qc1sxMF0qc1sxNV0gLSBzWzVdICpzWzExXSpzWzE0XSAtIHNbOV0gKnNbNl0qc1sxNV1cXHJcXG4gICAgICAgICAgICArIHNbOV0qc1s3XSAqc1sxNF0gKyBzWzEzXSpzWzZdICpzWzExXSAtIHNbMTNdKnNbN10qc1sxMF07XFxyXFxuICBpbnZbNF0gID0gLSBzWzRdKnNbMTBdKnNbMTVdICsgc1s0XSAqc1sxMV0qc1sxNF0gKyBzWzhdICpzWzZdKnNbMTVdXFxyXFxuICAgICAgICAgICAgLSBzWzhdKnNbN10gKnNbMTRdIC0gc1sxMl0qc1s2XSAqc1sxMV0gKyBzWzEyXSpzWzddKnNbMTBdO1xcclxcbiAgaW52WzhdICA9ICAgc1s0XSpzWzldICpzWzE1XSAtIHNbNF0gKnNbMTFdKnNbMTNdIC0gc1s4XSAqc1s1XSpzWzE1XVxcclxcbiAgICAgICAgICAgICsgc1s4XSpzWzddICpzWzEzXSArIHNbMTJdKnNbNV0gKnNbMTFdIC0gc1sxMl0qc1s3XSpzWzldO1xcclxcbiAgaW52WzEyXSA9IC0gc1s0XSpzWzldICpzWzE0XSArIHNbNF0gKnNbMTBdKnNbMTNdICsgc1s4XSAqc1s1XSpzWzE0XVxcclxcbiAgICAgICAgICAgIC0gc1s4XSpzWzZdICpzWzEzXSAtIHNbMTJdKnNbNV0gKnNbMTBdICsgc1sxMl0qc1s2XSpzWzldO1xcclxcblxcclxcbiAgaW52WzFdICA9IC0gc1sxXSpzWzEwXSpzWzE1XSArIHNbMV0gKnNbMTFdKnNbMTRdICsgc1s5XSAqc1syXSpzWzE1XVxcclxcbiAgICAgICAgICAgIC0gc1s5XSpzWzNdICpzWzE0XSAtIHNbMTNdKnNbMl0gKnNbMTFdICsgc1sxM10qc1szXSpzWzEwXTtcXHJcXG4gIGludls1XSAgPSAgIHNbMF0qc1sxMF0qc1sxNV0gLSBzWzBdICpzWzExXSpzWzE0XSAtIHNbOF0gKnNbMl0qc1sxNV1cXHJcXG4gICAgICAgICAgICArIHNbOF0qc1szXSAqc1sxNF0gKyBzWzEyXSpzWzJdICpzWzExXSAtIHNbMTJdKnNbM10qc1sxMF07XFxyXFxuICBpbnZbOV0gID0gLSBzWzBdKnNbOV0gKnNbMTVdICsgc1swXSAqc1sxMV0qc1sxM10gKyBzWzhdICpzWzFdKnNbMTVdXFxyXFxuICAgICAgICAgICAgLSBzWzhdKnNbM10gKnNbMTNdIC0gc1sxMl0qc1sxXSAqc1sxMV0gKyBzWzEyXSpzWzNdKnNbOV07XFxyXFxuICBpbnZbMTNdID0gICBzWzBdKnNbOV0gKnNbMTRdIC0gc1swXSAqc1sxMF0qc1sxM10gLSBzWzhdICpzWzFdKnNbMTRdXFxyXFxuICAgICAgICAgICAgKyBzWzhdKnNbMl0gKnNbMTNdICsgc1sxMl0qc1sxXSAqc1sxMF0gLSBzWzEyXSpzWzJdKnNbOV07XFxyXFxuXFxyXFxuICBpbnZbMl0gID0gICBzWzFdKnNbNl0qc1sxNV0gLSBzWzFdICpzWzddKnNbMTRdIC0gc1s1XSAqc1syXSpzWzE1XVxcclxcbiAgICAgICAgICAgICsgc1s1XSpzWzNdKnNbMTRdICsgc1sxM10qc1syXSpzWzddICAtIHNbMTNdKnNbM10qc1s2XTtcXHJcXG4gIGludls2XSAgPSAtIHNbMF0qc1s2XSpzWzE1XSArIHNbMF0gKnNbN10qc1sxNF0gKyBzWzRdICpzWzJdKnNbMTVdXFxyXFxuICAgICAgICAgICAgLSBzWzRdKnNbM10qc1sxNF0gLSBzWzEyXSpzWzJdKnNbN10gICsgc1sxMl0qc1szXSpzWzZdO1xcclxcbiAgaW52WzEwXSA9ICAgc1swXSpzWzVdKnNbMTVdIC0gc1swXSAqc1s3XSpzWzEzXSAtIHNbNF0gKnNbMV0qc1sxNV1cXHJcXG4gICAgICAgICAgICArIHNbNF0qc1szXSpzWzEzXSArIHNbMTJdKnNbMV0qc1s3XSAgLSBzWzEyXSpzWzNdKnNbNV07XFxyXFxuICBpbnZbMTRdID0gLSBzWzBdKnNbNV0qc1sxNF0gKyBzWzBdICpzWzZdKnNbMTNdICsgc1s0XSAqc1sxXSpzWzE0XVxcclxcbiAgICAgICAgICAgIC0gc1s0XSpzWzJdKnNbMTNdIC0gc1sxMl0qc1sxXSpzWzZdICArIHNbMTJdKnNbMl0qc1s1XTtcXHJcXG5cXHJcXG4gIGludlszXSAgPSAtIHNbMV0qc1s2XSpzWzExXSArIHNbMV0qc1s3XSpzWzEwXSArIHNbNV0qc1syXSpzWzExXVxcclxcbiAgICAgICAgICAgIC0gc1s1XSpzWzNdKnNbMTBdIC0gc1s5XSpzWzJdKnNbN10gICsgc1s5XSpzWzNdKnNbNl07XFxyXFxuICBpbnZbN10gID0gICBzWzBdKnNbNl0qc1sxMV0gLSBzWzBdKnNbN10qc1sxMF0gLSBzWzRdKnNbMl0qc1sxMV1cXHJcXG4gICAgICAgICAgICArIHNbNF0qc1szXSpzWzEwXSArIHNbOF0qc1syXSpzWzddICAtIHNbOF0qc1szXSpzWzZdO1xcclxcbiAgaW52WzExXSA9IC0gc1swXSpzWzVdKnNbMTFdICsgc1swXSpzWzddKnNbOV0gICsgc1s0XSpzWzFdKnNbMTFdXFxyXFxuICAgICAgICAgICAgLSBzWzRdKnNbM10qc1s5XSAgLSBzWzhdKnNbMV0qc1s3XSAgKyBzWzhdKnNbM10qc1s1XTtcXHJcXG4gIGludlsxNV0gPSAgIHNbMF0qc1s1XSpzWzEwXSAtIHNbMF0qc1s2XSpzWzldICAtIHNbNF0qc1sxXSpzWzEwXVxcclxcbiAgICAgICAgICAgICsgc1s0XSpzWzJdKnNbOV0gICsgc1s4XSpzWzFdKnNbNl0gIC0gc1s4XSpzWzJdKnNbNV07XFxyXFxuXFxyXFxuICBkZXQgPSBzWzBdKmludlswXSArIHNbMV0qaW52WzRdICsgc1syXSppbnZbOF0gKyBzWzNdKmludlsxMl07XFxyXFxuICBpZiAoZGV0ID09PSAwKSB7XFxyXFxuICAgIHJldHVybiB0aGlzO1xcclxcbiAgfVxcclxcblxcclxcbiAgZGV0ID0gMSAvIGRldDtcXHJcXG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XFxyXFxuICAgIGRbaV0gPSBpbnZbaV0gKiBkZXQ7XFxyXFxuICB9XFxyXFxuXFxyXFxuICByZXR1cm4gdGhpcztcXHJcXG59O1xcclxcblxcclxcbi8qKlxcclxcbiAqIENhbGN1bGF0ZSB0aGUgaW52ZXJzZSBtYXRyaXggb2YgdGhpcywgYW5kIHNldCB0byB0aGlzLlxcclxcbiAqIEByZXR1cm4gdGhpc1xcclxcbiAqL1xcclxcbk1hdHJpeDQucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uKCkge1xcclxcbiAgcmV0dXJuIHRoaXMuc2V0SW52ZXJzZU9mKHRoaXMpO1xcclxcbn07XFxyXFxuXFxyXFxuLyoqXFxyXFxuICogU2V0IHRoZSBvcnRob2dyYXBoaWMgcHJvamVjdGlvbiBtYXRyaXguXFxyXFxuICogQHBhcmFtIGxlZnQgVGhlIGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgb2YgY2xpcHBpbmcgcGxhbmUuXFxyXFxuICogQHBhcmFtIHJpZ2h0IFRoZSBjb29yZGluYXRlIG9mIHRoZSByaWdodCBvZiBjbGlwcGluZyBwbGFuZS5cXHJcXG4gKiBAcGFyYW0gYm90dG9tIFRoZSBjb29yZGluYXRlIG9mIHRoZSBib3R0b20gb2YgY2xpcHBpbmcgcGxhbmUuXFxyXFxuICogQHBhcmFtIHRvcCBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgdG9wIHRvcCBjbGlwcGluZyBwbGFuZS5cXHJcXG4gKiBAcGFyYW0gbmVhciBUaGUgZGlzdGFuY2VzIHRvIHRoZSBuZWFyZXIgZGVwdGggY2xpcHBpbmcgcGxhbmUuIFRoaXMgdmFsdWUgaXMgbWludXMgaWYgdGhlIHBsYW5lIGlzIHRvIGJlIGJlaGluZCB0aGUgdmlld2VyLlxcclxcbiAqIEBwYXJhbSBmYXIgVGhlIGRpc3RhbmNlcyB0byB0aGUgZmFydGhlciBkZXB0aCBjbGlwcGluZyBwbGFuZS4gVGhpcyB2YWx1ZSBpcyBtaW51cyBpZiB0aGUgcGxhbmUgaXMgdG8gYmUgYmVoaW5kIHRoZSB2aWV3ZXIuXFxyXFxuICogQHJldHVybiB0aGlzXFxyXFxuICovXFxyXFxuTWF0cml4NC5wcm90b3R5cGUuc2V0T3J0aG8gPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xcclxcbiAgdmFyIGUsIHJ3LCByaCwgcmQ7XFxyXFxuXFxyXFxuICBpZiAobGVmdCA9PT0gcmlnaHQgfHwgYm90dG9tID09PSB0b3AgfHwgbmVhciA9PT0gZmFyKSB7XFxyXFxuICAgIHRocm93ICdudWxsIGZydXN0dW0nO1xcclxcbiAgfVxcclxcblxcclxcbiAgcncgPSAxIC8gKHJpZ2h0IC0gbGVmdCk7XFxyXFxuICByaCA9IDEgLyAodG9wIC0gYm90dG9tKTtcXHJcXG4gIHJkID0gMSAvIChmYXIgLSBuZWFyKTtcXHJcXG5cXHJcXG4gIGUgPSB0aGlzLmVsZW1lbnRzO1xcclxcblxcclxcbiAgZVswXSAgPSAyICogcnc7XFxyXFxuICBlWzFdICA9IDA7XFxyXFxuICBlWzJdICA9IDA7XFxyXFxuICBlWzNdICA9IDA7XFxyXFxuXFxyXFxuICBlWzRdICA9IDA7XFxyXFxuICBlWzVdICA9IDIgKiByaDtcXHJcXG4gIGVbNl0gID0gMDtcXHJcXG4gIGVbN10gID0gMDtcXHJcXG5cXHJcXG4gIGVbOF0gID0gMDtcXHJcXG4gIGVbOV0gID0gMDtcXHJcXG4gIGVbMTBdID0gLTIgKiByZDtcXHJcXG4gIGVbMTFdID0gMDtcXHJcXG5cXHJcXG4gIGVbMTJdID0gLShyaWdodCArIGxlZnQpICogcnc7XFxyXFxuICBlWzEzXSA9IC0odG9wICsgYm90dG9tKSAqIHJoO1xcclxcbiAgZVsxNF0gPSAtKGZhciArIG5lYXIpICogcmQ7XFxyXFxuICBlWzE1XSA9IDE7XFxyXFxuXFxyXFxuICByZXR1cm4gdGhpcztcXHJcXG59O1xcclxcblxcclxcbi8qKlxcclxcbiAqIE11bHRpcGx5IHRoZSBvcnRob2dyYXBoaWMgcHJvamVjdGlvbiBtYXRyaXggZnJvbSB0aGUgcmlnaHQuXFxyXFxuICogQHBhcmFtIGxlZnQgVGhlIGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgb2YgY2xpcHBpbmcgcGxhbmUuXFxyXFxuICogQHBhcmFtIHJpZ2h0IFRoZSBjb29yZGluYXRlIG9mIHRoZSByaWdodCBvZiBjbGlwcGluZyBwbGFuZS5cXHJcXG4gKiBAcGFyYW0gYm90dG9tIFRoZSBjb29yZGluYXRlIG9mIHRoZSBib3R0b20gb2YgY2xpcHBpbmcgcGxhbmUuXFxyXFxuICogQHBhcmFtIHRvcCBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgdG9wIHRvcCBjbGlwcGluZyBwbGFuZS5cXHJcXG4gKiBAcGFyYW0gbmVhciBUaGUgZGlzdGFuY2VzIHRvIHRoZSBuZWFyZXIgZGVwdGggY2xpcHBpbmcgcGxhbmUuIFRoaXMgdmFsdWUgaXMgbWludXMgaWYgdGhlIHBsYW5lIGlzIHRvIGJlIGJlaGluZCB0aGUgdmlld2VyLlxcclxcbiAqIEBwYXJhbSBmYXIgVGhlIGRpc3RhbmNlcyB0byB0aGUgZmFydGhlciBkZXB0aCBjbGlwcGluZyBwbGFuZS4gVGhpcyB2YWx1ZSBpcyBtaW51cyBpZiB0aGUgcGxhbmUgaXMgdG8gYmUgYmVoaW5kIHRoZSB2aWV3ZXIuXFxyXFxuICogQHJldHVybiB0aGlzXFxyXFxuICovXFxyXFxuTWF0cml4NC5wcm90b3R5cGUub3J0aG8gPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xcclxcbiAgcmV0dXJuIHRoaXMuY29uY2F0KG5ldyBNYXRyaXg0KCkuc2V0T3J0aG8obGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpKTtcXHJcXG59O1xcclxcblxcclxcbi8qKlxcclxcbiAqIFNldCB0aGUgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXguXFxyXFxuICogQHBhcmFtIGxlZnQgVGhlIGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgb2YgY2xpcHBpbmcgcGxhbmUuXFxyXFxuICogQHBhcmFtIHJpZ2h0IFRoZSBjb29yZGluYXRlIG9mIHRoZSByaWdodCBvZiBjbGlwcGluZyBwbGFuZS5cXHJcXG4gKiBAcGFyYW0gYm90dG9tIFRoZSBjb29yZGluYXRlIG9mIHRoZSBib3R0b20gb2YgY2xpcHBpbmcgcGxhbmUuXFxyXFxuICogQHBhcmFtIHRvcCBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgdG9wIHRvcCBjbGlwcGluZyBwbGFuZS5cXHJcXG4gKiBAcGFyYW0gbmVhciBUaGUgZGlzdGFuY2VzIHRvIHRoZSBuZWFyZXIgZGVwdGggY2xpcHBpbmcgcGxhbmUuIFRoaXMgdmFsdWUgbXVzdCBiZSBwbHVzIHZhbHVlLlxcclxcbiAqIEBwYXJhbSBmYXIgVGhlIGRpc3RhbmNlcyB0byB0aGUgZmFydGhlciBkZXB0aCBjbGlwcGluZyBwbGFuZS4gVGhpcyB2YWx1ZSBtdXN0IGJlIHBsdXMgdmFsdWUuXFxyXFxuICogQHJldHVybiB0aGlzXFxyXFxuICovXFxyXFxuTWF0cml4NC5wcm90b3R5cGUuc2V0RnJ1c3R1bSA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XFxyXFxuICB2YXIgZSwgcncsIHJoLCByZDtcXHJcXG5cXHJcXG4gIGlmIChsZWZ0ID09PSByaWdodCB8fCB0b3AgPT09IGJvdHRvbSB8fCBuZWFyID09PSBmYXIpIHtcXHJcXG4gICAgdGhyb3cgJ251bGwgZnJ1c3R1bSc7XFxyXFxuICB9XFxyXFxuICBpZiAobmVhciA8PSAwKSB7XFxyXFxuICAgIHRocm93ICduZWFyIDw9IDAnO1xcclxcbiAgfVxcclxcbiAgaWYgKGZhciA8PSAwKSB7XFxyXFxuICAgIHRocm93ICdmYXIgPD0gMCc7XFxyXFxuICB9XFxyXFxuXFxyXFxuICBydyA9IDEgLyAocmlnaHQgLSBsZWZ0KTtcXHJcXG4gIHJoID0gMSAvICh0b3AgLSBib3R0b20pO1xcclxcbiAgcmQgPSAxIC8gKGZhciAtIG5lYXIpO1xcclxcblxcclxcbiAgZSA9IHRoaXMuZWxlbWVudHM7XFxyXFxuXFxyXFxuICBlWyAwXSA9IDIgKiBuZWFyICogcnc7XFxyXFxuICBlWyAxXSA9IDA7XFxyXFxuICBlWyAyXSA9IDA7XFxyXFxuICBlWyAzXSA9IDA7XFxyXFxuXFxyXFxuICBlWyA0XSA9IDA7XFxyXFxuICBlWyA1XSA9IDIgKiBuZWFyICogcmg7XFxyXFxuICBlWyA2XSA9IDA7XFxyXFxuICBlWyA3XSA9IDA7XFxyXFxuXFxyXFxuICBlWyA4XSA9IChyaWdodCArIGxlZnQpICogcnc7XFxyXFxuICBlWyA5XSA9ICh0b3AgKyBib3R0b20pICogcmg7XFxyXFxuICBlWzEwXSA9IC0oZmFyICsgbmVhcikgKiByZDtcXHJcXG4gIGVbMTFdID0gLTE7XFxyXFxuXFxyXFxuICBlWzEyXSA9IDA7XFxyXFxuICBlWzEzXSA9IDA7XFxyXFxuICBlWzE0XSA9IC0yICogbmVhciAqIGZhciAqIHJkO1xcclxcbiAgZVsxNV0gPSAwO1xcclxcblxcclxcbiAgcmV0dXJuIHRoaXM7XFxyXFxufTtcXHJcXG5cXHJcXG4vKipcXHJcXG4gKiBNdWx0aXBseSB0aGUgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggZnJvbSB0aGUgcmlnaHQuXFxyXFxuICogQHBhcmFtIGxlZnQgVGhlIGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgb2YgY2xpcHBpbmcgcGxhbmUuXFxyXFxuICogQHBhcmFtIHJpZ2h0IFRoZSBjb29yZGluYXRlIG9mIHRoZSByaWdodCBvZiBjbGlwcGluZyBwbGFuZS5cXHJcXG4gKiBAcGFyYW0gYm90dG9tIFRoZSBjb29yZGluYXRlIG9mIHRoZSBib3R0b20gb2YgY2xpcHBpbmcgcGxhbmUuXFxyXFxuICogQHBhcmFtIHRvcCBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgdG9wIHRvcCBjbGlwcGluZyBwbGFuZS5cXHJcXG4gKiBAcGFyYW0gbmVhciBUaGUgZGlzdGFuY2VzIHRvIHRoZSBuZWFyZXIgZGVwdGggY2xpcHBpbmcgcGxhbmUuIFRoaXMgdmFsdWUgbXVzdCBiZSBwbHVzIHZhbHVlLlxcclxcbiAqIEBwYXJhbSBmYXIgVGhlIGRpc3RhbmNlcyB0byB0aGUgZmFydGhlciBkZXB0aCBjbGlwcGluZyBwbGFuZS4gVGhpcyB2YWx1ZSBtdXN0IGJlIHBsdXMgdmFsdWUuXFxyXFxuICogQHJldHVybiB0aGlzXFxyXFxuICovXFxyXFxuTWF0cml4NC5wcm90b3R5cGUuZnJ1c3R1bSA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XFxyXFxuICByZXR1cm4gdGhpcy5jb25jYXQobmV3IE1hdHJpeDQoKS5zZXRGcnVzdHVtKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSk7XFxyXFxufTtcXHJcXG5cXHJcXG4vKipcXHJcXG4gKiBTZXQgdGhlIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IGJ5IGZvdnkgYW5kIGFzcGVjdC5cXHJcXG4gKiBAcGFyYW0gZm92eSBUaGUgYW5nbGUgYmV0d2VlbiB0aGUgdXBwZXIgYW5kIGxvd2VyIHNpZGVzIG9mIHRoZSBmcnVzdHVtLlxcclxcbiAqIEBwYXJhbSBhc3BlY3QgVGhlIGFzcGVjdCByYXRpbyBvZiB0aGUgZnJ1c3R1bS4gKHdpZHRoL2hlaWdodClcXHJcXG4gKiBAcGFyYW0gbmVhciBUaGUgZGlzdGFuY2VzIHRvIHRoZSBuZWFyZXIgZGVwdGggY2xpcHBpbmcgcGxhbmUuIFRoaXMgdmFsdWUgbXVzdCBiZSBwbHVzIHZhbHVlLlxcclxcbiAqIEBwYXJhbSBmYXIgVGhlIGRpc3RhbmNlcyB0byB0aGUgZmFydGhlciBkZXB0aCBjbGlwcGluZyBwbGFuZS4gVGhpcyB2YWx1ZSBtdXN0IGJlIHBsdXMgdmFsdWUuXFxyXFxuICogQHJldHVybiB0aGlzXFxyXFxuICovXFxyXFxuTWF0cml4NC5wcm90b3R5cGUuc2V0UGVyc3BlY3RpdmUgPSBmdW5jdGlvbihmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xcclxcbiAgdmFyIGUsIHJkLCBzLCBjdDtcXHJcXG5cXHJcXG4gIGlmIChuZWFyID09PSBmYXIgfHwgYXNwZWN0ID09PSAwKSB7XFxyXFxuICAgIHRocm93ICdudWxsIGZydXN0dW0nO1xcclxcbiAgfVxcclxcbiAgaWYgKG5lYXIgPD0gMCkge1xcclxcbiAgICB0aHJvdyAnbmVhciA8PSAwJztcXHJcXG4gIH1cXHJcXG4gIGlmIChmYXIgPD0gMCkge1xcclxcbiAgICB0aHJvdyAnZmFyIDw9IDAnO1xcclxcbiAgfVxcclxcblxcclxcbiAgZm92eSA9IE1hdGguUEkgKiBmb3Z5IC8gMTgwIC8gMjtcXHJcXG4gIHMgPSBNYXRoLnNpbihmb3Z5KTtcXHJcXG4gIGlmIChzID09PSAwKSB7XFxyXFxuICAgIHRocm93ICdudWxsIGZydXN0dW0nO1xcclxcbiAgfVxcclxcblxcclxcbiAgcmQgPSAxIC8gKGZhciAtIG5lYXIpO1xcclxcbiAgY3QgPSBNYXRoLmNvcyhmb3Z5KSAvIHM7XFxyXFxuXFxyXFxuICBlID0gdGhpcy5lbGVtZW50cztcXHJcXG5cXHJcXG4gIGVbMF0gID0gY3QgLyBhc3BlY3Q7XFxyXFxuICBlWzFdICA9IDA7XFxyXFxuICBlWzJdICA9IDA7XFxyXFxuICBlWzNdICA9IDA7XFxyXFxuXFxyXFxuICBlWzRdICA9IDA7XFxyXFxuICBlWzVdICA9IGN0O1xcclxcbiAgZVs2XSAgPSAwO1xcclxcbiAgZVs3XSAgPSAwO1xcclxcblxcclxcbiAgZVs4XSAgPSAwO1xcclxcbiAgZVs5XSAgPSAwO1xcclxcbiAgZVsxMF0gPSAtKGZhciArIG5lYXIpICogcmQ7XFxyXFxuICBlWzExXSA9IC0xO1xcclxcblxcclxcbiAgZVsxMl0gPSAwO1xcclxcbiAgZVsxM10gPSAwO1xcclxcbiAgZVsxNF0gPSAtMiAqIG5lYXIgKiBmYXIgKiByZDtcXHJcXG4gIGVbMTVdID0gMDtcXHJcXG5cXHJcXG4gIHJldHVybiB0aGlzO1xcclxcbn07XFxyXFxuXFxyXFxuLyoqXFxyXFxuICogTXVsdGlwbHkgdGhlIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IGZyb20gdGhlIHJpZ2h0LlxcclxcbiAqIEBwYXJhbSBmb3Z5IFRoZSBhbmdsZSBiZXR3ZWVuIHRoZSB1cHBlciBhbmQgbG93ZXIgc2lkZXMgb2YgdGhlIGZydXN0dW0uXFxyXFxuICogQHBhcmFtIGFzcGVjdCBUaGUgYXNwZWN0IHJhdGlvIG9mIHRoZSBmcnVzdHVtLiAod2lkdGgvaGVpZ2h0KVxcclxcbiAqIEBwYXJhbSBuZWFyIFRoZSBkaXN0YW5jZXMgdG8gdGhlIG5lYXJlciBkZXB0aCBjbGlwcGluZyBwbGFuZS4gVGhpcyB2YWx1ZSBtdXN0IGJlIHBsdXMgdmFsdWUuXFxyXFxuICogQHBhcmFtIGZhciBUaGUgZGlzdGFuY2VzIHRvIHRoZSBmYXJ0aGVyIGRlcHRoIGNsaXBwaW5nIHBsYW5lLiBUaGlzIHZhbHVlIG11c3QgYmUgcGx1cyB2YWx1ZS5cXHJcXG4gKiBAcmV0dXJuIHRoaXNcXHJcXG4gKi9cXHJcXG5NYXRyaXg0LnByb3RvdHlwZS5wZXJzcGVjdGl2ZSA9IGZ1bmN0aW9uKGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKSB7XFxyXFxuICByZXR1cm4gdGhpcy5jb25jYXQobmV3IE1hdHJpeDQoKS5zZXRQZXJzcGVjdGl2ZShmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikpO1xcclxcbn07XFxyXFxuXFxyXFxuLyoqXFxyXFxuICogU2V0IHRoZSBtYXRyaXggZm9yIHNjYWxpbmcuXFxyXFxuICogQHBhcmFtIHggVGhlIHNjYWxlIGZhY3RvciBhbG9uZyB0aGUgWCBheGlzXFxyXFxuICogQHBhcmFtIHkgVGhlIHNjYWxlIGZhY3RvciBhbG9uZyB0aGUgWSBheGlzXFxyXFxuICogQHBhcmFtIHogVGhlIHNjYWxlIGZhY3RvciBhbG9uZyB0aGUgWiBheGlzXFxyXFxuICogQHJldHVybiB0aGlzXFxyXFxuICovXFxyXFxuTWF0cml4NC5wcm90b3R5cGUuc2V0U2NhbGUgPSBmdW5jdGlvbih4LCB5LCB6KSB7XFxyXFxuICB2YXIgZSA9IHRoaXMuZWxlbWVudHM7XFxyXFxuICBlWzBdID0geDsgIGVbNF0gPSAwOyAgZVs4XSAgPSAwOyAgZVsxMl0gPSAwO1xcclxcbiAgZVsxXSA9IDA7ICBlWzVdID0geTsgIGVbOV0gID0gMDsgIGVbMTNdID0gMDtcXHJcXG4gIGVbMl0gPSAwOyAgZVs2XSA9IDA7ICBlWzEwXSA9IHo7ICBlWzE0XSA9IDA7XFxyXFxuICBlWzNdID0gMDsgIGVbN10gPSAwOyAgZVsxMV0gPSAwOyAgZVsxNV0gPSAxO1xcclxcbiAgcmV0dXJuIHRoaXM7XFxyXFxufTtcXHJcXG5cXHJcXG4vKipcXHJcXG4gKiBNdWx0aXBseSB0aGUgbWF0cml4IGZvciBzY2FsaW5nIGZyb20gdGhlIHJpZ2h0LlxcclxcbiAqIEBwYXJhbSB4IFRoZSBzY2FsZSBmYWN0b3IgYWxvbmcgdGhlIFggYXhpc1xcclxcbiAqIEBwYXJhbSB5IFRoZSBzY2FsZSBmYWN0b3IgYWxvbmcgdGhlIFkgYXhpc1xcclxcbiAqIEBwYXJhbSB6IFRoZSBzY2FsZSBmYWN0b3IgYWxvbmcgdGhlIFogYXhpc1xcclxcbiAqIEByZXR1cm4gdGhpc1xcclxcbiAqL1xcclxcbk1hdHJpeDQucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24oeCwgeSwgeikge1xcclxcbiAgdmFyIGUgPSB0aGlzLmVsZW1lbnRzO1xcclxcbiAgZVswXSAqPSB4OyAgZVs0XSAqPSB5OyAgZVs4XSAgKj0gejtcXHJcXG4gIGVbMV0gKj0geDsgIGVbNV0gKj0geTsgIGVbOV0gICo9IHo7XFxyXFxuICBlWzJdICo9IHg7ICBlWzZdICo9IHk7ICBlWzEwXSAqPSB6O1xcclxcbiAgZVszXSAqPSB4OyAgZVs3XSAqPSB5OyAgZVsxMV0gKj0gejtcXHJcXG4gIHJldHVybiB0aGlzO1xcclxcbn07XFxyXFxuXFxyXFxuLyoqXFxyXFxuICogU2V0IHRoZSBtYXRyaXggZm9yIHRyYW5zbGF0aW9uLlxcclxcbiAqIEBwYXJhbSB4IFRoZSBYIHZhbHVlIG9mIGEgdHJhbnNsYXRpb24uXFxyXFxuICogQHBhcmFtIHkgVGhlIFkgdmFsdWUgb2YgYSB0cmFuc2xhdGlvbi5cXHJcXG4gKiBAcGFyYW0geiBUaGUgWiB2YWx1ZSBvZiBhIHRyYW5zbGF0aW9uLlxcclxcbiAqIEByZXR1cm4gdGhpc1xcclxcbiAqL1xcclxcbk1hdHJpeDQucHJvdG90eXBlLnNldFRyYW5zbGF0ZSA9IGZ1bmN0aW9uKHgsIHksIHopIHtcXHJcXG4gIHZhciBlID0gdGhpcy5lbGVtZW50cztcXHJcXG4gIGVbMF0gPSAxOyAgZVs0XSA9IDA7ICBlWzhdICA9IDA7ICBlWzEyXSA9IHg7XFxyXFxuICBlWzFdID0gMDsgIGVbNV0gPSAxOyAgZVs5XSAgPSAwOyAgZVsxM10gPSB5O1xcclxcbiAgZVsyXSA9IDA7ICBlWzZdID0gMDsgIGVbMTBdID0gMTsgIGVbMTRdID0gejtcXHJcXG4gIGVbM10gPSAwOyAgZVs3XSA9IDA7ICBlWzExXSA9IDA7ICBlWzE1XSA9IDE7XFxyXFxuICByZXR1cm4gdGhpcztcXHJcXG59O1xcclxcblxcclxcbi8qKlxcclxcbiAqIE11bHRpcGx5IHRoZSBtYXRyaXggZm9yIHRyYW5zbGF0aW9uIGZyb20gdGhlIHJpZ2h0LlxcclxcbiAqIEBwYXJhbSB4IFRoZSBYIHZhbHVlIG9mIGEgdHJhbnNsYXRpb24uXFxyXFxuICogQHBhcmFtIHkgVGhlIFkgdmFsdWUgb2YgYSB0cmFuc2xhdGlvbi5cXHJcXG4gKiBAcGFyYW0geiBUaGUgWiB2YWx1ZSBvZiBhIHRyYW5zbGF0aW9uLlxcclxcbiAqIEByZXR1cm4gdGhpc1xcclxcbiAqL1xcclxcbk1hdHJpeDQucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKHgsIHksIHopIHtcXHJcXG4gIHZhciBlID0gdGhpcy5lbGVtZW50cztcXHJcXG4gIGVbMTJdICs9IGVbMF0gKiB4ICsgZVs0XSAqIHkgKyBlWzhdICAqIHo7XFxyXFxuICBlWzEzXSArPSBlWzFdICogeCArIGVbNV0gKiB5ICsgZVs5XSAgKiB6O1xcclxcbiAgZVsxNF0gKz0gZVsyXSAqIHggKyBlWzZdICogeSArIGVbMTBdICogejtcXHJcXG4gIGVbMTVdICs9IGVbM10gKiB4ICsgZVs3XSAqIHkgKyBlWzExXSAqIHo7XFxyXFxuICByZXR1cm4gdGhpcztcXHJcXG59O1xcclxcblxcclxcbi8qKlxcclxcbiAqIFNldCB0aGUgbWF0cml4IGZvciByb3RhdGlvbi5cXHJcXG4gKiBUaGUgdmVjdG9yIG9mIHJvdGF0aW9uIGF4aXMgbWF5IG5vdCBiZSBub3JtYWxpemVkLlxcclxcbiAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgb2Ygcm90YXRpb24gKGRlZ3JlZXMpXFxyXFxuICogQHBhcmFtIHggVGhlIFggY29vcmRpbmF0ZSBvZiB2ZWN0b3Igb2Ygcm90YXRpb24gYXhpcy5cXHJcXG4gKiBAcGFyYW0geSBUaGUgWSBjb29yZGluYXRlIG9mIHZlY3RvciBvZiByb3RhdGlvbiBheGlzLlxcclxcbiAqIEBwYXJhbSB6IFRoZSBaIGNvb3JkaW5hdGUgb2YgdmVjdG9yIG9mIHJvdGF0aW9uIGF4aXMuXFxyXFxuICogQHJldHVybiB0aGlzXFxyXFxuICovXFxyXFxuTWF0cml4NC5wcm90b3R5cGUuc2V0Um90YXRlID0gZnVuY3Rpb24oYW5nbGUsIHgsIHksIHopIHtcXHJcXG4gIHZhciBlLCBzLCBjLCBsZW4sIHJsZW4sIG5jLCB4eSwgeXosIHp4LCB4cywgeXMsIHpzO1xcclxcblxcclxcbiAgYW5nbGUgPSBNYXRoLlBJICogYW5nbGUgLyAxODA7XFxyXFxuICBlID0gdGhpcy5lbGVtZW50cztcXHJcXG5cXHJcXG4gIHMgPSBNYXRoLnNpbihhbmdsZSk7XFxyXFxuICBjID0gTWF0aC5jb3MoYW5nbGUpO1xcclxcblxcclxcbiAgaWYgKDAgIT09IHggJiYgMCA9PT0geSAmJiAwID09PSB6KSB7XFxyXFxuICAgIC8vIFJvdGF0aW9uIGFyb3VuZCBYIGF4aXNcXHJcXG4gICAgaWYgKHggPCAwKSB7XFxyXFxuICAgICAgcyA9IC1zO1xcclxcbiAgICB9XFxyXFxuICAgIGVbMF0gPSAxOyAgZVs0XSA9IDA7ICBlWyA4XSA9IDA7ICBlWzEyXSA9IDA7XFxyXFxuICAgIGVbMV0gPSAwOyAgZVs1XSA9IGM7ICBlWyA5XSA9LXM7ICBlWzEzXSA9IDA7XFxyXFxuICAgIGVbMl0gPSAwOyAgZVs2XSA9IHM7ICBlWzEwXSA9IGM7ICBlWzE0XSA9IDA7XFxyXFxuICAgIGVbM10gPSAwOyAgZVs3XSA9IDA7ICBlWzExXSA9IDA7ICBlWzE1XSA9IDE7XFxyXFxuICB9IGVsc2UgaWYgKDAgPT09IHggJiYgMCAhPT0geSAmJiAwID09PSB6KSB7XFxyXFxuICAgIC8vIFJvdGF0aW9uIGFyb3VuZCBZIGF4aXNcXHJcXG4gICAgaWYgKHkgPCAwKSB7XFxyXFxuICAgICAgcyA9IC1zO1xcclxcbiAgICB9XFxyXFxuICAgIGVbMF0gPSBjOyAgZVs0XSA9IDA7ICBlWyA4XSA9IHM7ICBlWzEyXSA9IDA7XFxyXFxuICAgIGVbMV0gPSAwOyAgZVs1XSA9IDE7ICBlWyA5XSA9IDA7ICBlWzEzXSA9IDA7XFxyXFxuICAgIGVbMl0gPS1zOyAgZVs2XSA9IDA7ICBlWzEwXSA9IGM7ICBlWzE0XSA9IDA7XFxyXFxuICAgIGVbM10gPSAwOyAgZVs3XSA9IDA7ICBlWzExXSA9IDA7ICBlWzE1XSA9IDE7XFxyXFxuICB9IGVsc2UgaWYgKDAgPT09IHggJiYgMCA9PT0geSAmJiAwICE9PSB6KSB7XFxyXFxuICAgIC8vIFJvdGF0aW9uIGFyb3VuZCBaIGF4aXNcXHJcXG4gICAgaWYgKHogPCAwKSB7XFxyXFxuICAgICAgcyA9IC1zO1xcclxcbiAgICB9XFxyXFxuICAgIGVbMF0gPSBjOyAgZVs0XSA9LXM7ICBlWyA4XSA9IDA7ICBlWzEyXSA9IDA7XFxyXFxuICAgIGVbMV0gPSBzOyAgZVs1XSA9IGM7ICBlWyA5XSA9IDA7ICBlWzEzXSA9IDA7XFxyXFxuICAgIGVbMl0gPSAwOyAgZVs2XSA9IDA7ICBlWzEwXSA9IDE7ICBlWzE0XSA9IDA7XFxyXFxuICAgIGVbM10gPSAwOyAgZVs3XSA9IDA7ICBlWzExXSA9IDA7ICBlWzE1XSA9IDE7XFxyXFxuICB9IGVsc2Uge1xcclxcbiAgICAvLyBSb3RhdGlvbiBhcm91bmQgYW5vdGhlciBheGlzXFxyXFxuICAgIGxlbiA9IE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopO1xcclxcbiAgICBpZiAobGVuICE9PSAxKSB7XFxyXFxuICAgICAgcmxlbiA9IDEgLyBsZW47XFxyXFxuICAgICAgeCAqPSBybGVuO1xcclxcbiAgICAgIHkgKj0gcmxlbjtcXHJcXG4gICAgICB6ICo9IHJsZW47XFxyXFxuICAgIH1cXHJcXG4gICAgbmMgPSAxIC0gYztcXHJcXG4gICAgeHkgPSB4ICogeTtcXHJcXG4gICAgeXogPSB5ICogejtcXHJcXG4gICAgenggPSB6ICogeDtcXHJcXG4gICAgeHMgPSB4ICogcztcXHJcXG4gICAgeXMgPSB5ICogcztcXHJcXG4gICAgenMgPSB6ICogcztcXHJcXG5cXHJcXG4gICAgZVsgMF0gPSB4KngqbmMgKyAgYztcXHJcXG4gICAgZVsgMV0gPSB4eSAqbmMgKyB6cztcXHJcXG4gICAgZVsgMl0gPSB6eCAqbmMgLSB5cztcXHJcXG4gICAgZVsgM10gPSAwO1xcclxcblxcclxcbiAgICBlWyA0XSA9IHh5ICpuYyAtIHpzO1xcclxcbiAgICBlWyA1XSA9IHkqeSpuYyArICBjO1xcclxcbiAgICBlWyA2XSA9IHl6ICpuYyArIHhzO1xcclxcbiAgICBlWyA3XSA9IDA7XFxyXFxuXFxyXFxuICAgIGVbIDhdID0genggKm5jICsgeXM7XFxyXFxuICAgIGVbIDldID0geXogKm5jIC0geHM7XFxyXFxuICAgIGVbMTBdID0geip6Km5jICsgIGM7XFxyXFxuICAgIGVbMTFdID0gMDtcXHJcXG5cXHJcXG4gICAgZVsxMl0gPSAwO1xcclxcbiAgICBlWzEzXSA9IDA7XFxyXFxuICAgIGVbMTRdID0gMDtcXHJcXG4gICAgZVsxNV0gPSAxO1xcclxcbiAgfVxcclxcblxcclxcbiAgcmV0dXJuIHRoaXM7XFxyXFxufTtcXHJcXG5cXHJcXG4vKipcXHJcXG4gKiBNdWx0aXBseSB0aGUgbWF0cml4IGZvciByb3RhdGlvbiBmcm9tIHRoZSByaWdodC5cXHJcXG4gKiBUaGUgdmVjdG9yIG9mIHJvdGF0aW9uIGF4aXMgbWF5IG5vdCBiZSBub3JtYWxpemVkLlxcclxcbiAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgb2Ygcm90YXRpb24gKGRlZ3JlZXMpXFxyXFxuICogQHBhcmFtIHggVGhlIFggY29vcmRpbmF0ZSBvZiB2ZWN0b3Igb2Ygcm90YXRpb24gYXhpcy5cXHJcXG4gKiBAcGFyYW0geSBUaGUgWSBjb29yZGluYXRlIG9mIHZlY3RvciBvZiByb3RhdGlvbiBheGlzLlxcclxcbiAqIEBwYXJhbSB6IFRoZSBaIGNvb3JkaW5hdGUgb2YgdmVjdG9yIG9mIHJvdGF0aW9uIGF4aXMuXFxyXFxuICogQHJldHVybiB0aGlzXFxyXFxuICovXFxyXFxuTWF0cml4NC5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24oYW5nbGUsIHgsIHksIHopIHtcXHJcXG4gIHJldHVybiB0aGlzLmNvbmNhdChuZXcgTWF0cml4NCgpLnNldFJvdGF0ZShhbmdsZSwgeCwgeSwgeikpO1xcclxcbn07XFxyXFxuXFxyXFxuLyoqXFxyXFxuICogU2V0IHRoZSB2aWV3aW5nIG1hdHJpeC5cXHJcXG4gKiBAcGFyYW0gZXllWCwgZXllWSwgZXllWiBUaGUgcG9zaXRpb24gb2YgdGhlIGV5ZSBwb2ludC5cXHJcXG4gKiBAcGFyYW0gY2VudGVyWCwgY2VudGVyWSwgY2VudGVyWiBUaGUgcG9zaXRpb24gb2YgdGhlIHJlZmVyZW5jZSBwb2ludC5cXHJcXG4gKiBAcGFyYW0gdXBYLCB1cFksIHVwWiBUaGUgZGlyZWN0aW9uIG9mIHRoZSB1cCB2ZWN0b3IuXFxyXFxuICogQHJldHVybiB0aGlzXFxyXFxuICovXFxyXFxuTWF0cml4NC5wcm90b3R5cGUuc2V0TG9va0F0ID0gZnVuY3Rpb24oZXllWCwgZXllWSwgZXllWiwgY2VudGVyWCwgY2VudGVyWSwgY2VudGVyWiwgdXBYLCB1cFksIHVwWikge1xcclxcbiAgdmFyIGUsIGZ4LCBmeSwgZnosIHJsZiwgc3gsIHN5LCBzeiwgcmxzLCB1eCwgdXksIHV6O1xcclxcblxcclxcbiAgZnggPSBjZW50ZXJYIC0gZXllWDtcXHJcXG4gIGZ5ID0gY2VudGVyWSAtIGV5ZVk7XFxyXFxuICBmeiA9IGNlbnRlclogLSBleWVaO1xcclxcblxcclxcbiAgLy8gTm9ybWFsaXplIGYuXFxyXFxuICBybGYgPSAxIC8gTWF0aC5zcXJ0KGZ4KmZ4ICsgZnkqZnkgKyBmeipmeik7XFxyXFxuICBmeCAqPSBybGY7XFxyXFxuICBmeSAqPSBybGY7XFxyXFxuICBmeiAqPSBybGY7XFxyXFxuXFxyXFxuICAvLyBDYWxjdWxhdGUgY3Jvc3MgcHJvZHVjdCBvZiBmIGFuZCB1cC5cXHJcXG4gIHN4ID0gZnkgKiB1cFogLSBmeiAqIHVwWTtcXHJcXG4gIHN5ID0gZnogKiB1cFggLSBmeCAqIHVwWjtcXHJcXG4gIHN6ID0gZnggKiB1cFkgLSBmeSAqIHVwWDtcXHJcXG5cXHJcXG4gIC8vIE5vcm1hbGl6ZSBzLlxcclxcbiAgcmxzID0gMSAvIE1hdGguc3FydChzeCpzeCArIHN5KnN5ICsgc3oqc3opO1xcclxcbiAgc3ggKj0gcmxzO1xcclxcbiAgc3kgKj0gcmxzO1xcclxcbiAgc3ogKj0gcmxzO1xcclxcblxcclxcbiAgLy8gQ2FsY3VsYXRlIGNyb3NzIHByb2R1Y3Qgb2YgcyBhbmQgZi5cXHJcXG4gIHV4ID0gc3kgKiBmeiAtIHN6ICogZnk7XFxyXFxuICB1eSA9IHN6ICogZnggLSBzeCAqIGZ6O1xcclxcbiAgdXogPSBzeCAqIGZ5IC0gc3kgKiBmeDtcXHJcXG5cXHJcXG4gIC8vIFNldCB0byB0aGlzLlxcclxcbiAgZSA9IHRoaXMuZWxlbWVudHM7XFxyXFxuICBlWzBdID0gc3g7XFxyXFxuICBlWzFdID0gdXg7XFxyXFxuICBlWzJdID0gLWZ4O1xcclxcbiAgZVszXSA9IDA7XFxyXFxuXFxyXFxuICBlWzRdID0gc3k7XFxyXFxuICBlWzVdID0gdXk7XFxyXFxuICBlWzZdID0gLWZ5O1xcclxcbiAgZVs3XSA9IDA7XFxyXFxuXFxyXFxuICBlWzhdID0gc3o7XFxyXFxuICBlWzldID0gdXo7XFxyXFxuICBlWzEwXSA9IC1mejtcXHJcXG4gIGVbMTFdID0gMDtcXHJcXG5cXHJcXG4gIGVbMTJdID0gMDtcXHJcXG4gIGVbMTNdID0gMDtcXHJcXG4gIGVbMTRdID0gMDtcXHJcXG4gIGVbMTVdID0gMTtcXHJcXG5cXHJcXG4gIC8vIFRyYW5zbGF0ZS5cXHJcXG4gIHJldHVybiB0aGlzLnRyYW5zbGF0ZSgtZXllWCwgLWV5ZVksIC1leWVaKTtcXHJcXG59O1xcclxcblxcclxcbi8qKlxcclxcbiAqIE11bHRpcGx5IHRoZSB2aWV3aW5nIG1hdHJpeCBmcm9tIHRoZSByaWdodC5cXHJcXG4gKiBAcGFyYW0gZXllWCwgZXllWSwgZXllWiBUaGUgcG9zaXRpb24gb2YgdGhlIGV5ZSBwb2ludC5cXHJcXG4gKiBAcGFyYW0gY2VudGVyWCwgY2VudGVyWSwgY2VudGVyWiBUaGUgcG9zaXRpb24gb2YgdGhlIHJlZmVyZW5jZSBwb2ludC5cXHJcXG4gKiBAcGFyYW0gdXBYLCB1cFksIHVwWiBUaGUgZGlyZWN0aW9uIG9mIHRoZSB1cCB2ZWN0b3IuXFxyXFxuICogQHJldHVybiB0aGlzXFxyXFxuICovXFxyXFxuTWF0cml4NC5wcm90b3R5cGUubG9va0F0ID0gZnVuY3Rpb24oZXllWCwgZXllWSwgZXllWiwgY2VudGVyWCwgY2VudGVyWSwgY2VudGVyWiwgdXBYLCB1cFksIHVwWikge1xcclxcbiAgcmV0dXJuIHRoaXMuY29uY2F0KG5ldyBNYXRyaXg0KCkuc2V0TG9va0F0KGV5ZVgsIGV5ZVksIGV5ZVosIGNlbnRlclgsIGNlbnRlclksIGNlbnRlclosIHVwWCwgdXBZLCB1cFopKTtcXHJcXG59O1xcclxcblxcclxcbi8qKlxcclxcbiAqIE11bHRpcGx5IHRoZSBtYXRyaXggZm9yIHByb2plY3QgdmVydGV4IHRvIHBsYW5lIGZyb20gdGhlIHJpZ2h0LlxcclxcbiAqIEBwYXJhbSBwbGFuZSBUaGUgYXJyYXlbQSwgQiwgQywgRF0gb2YgdGhlIGVxdWF0aW9uIG9mIHBsYW5lIFxcXCJBeCArIEJ5ICsgQ3ogKyBEID0gMFxcXCIuXFxyXFxuICogQHBhcmFtIGxpZ2h0IFRoZSBhcnJheSB3aGljaCBzdG9yZWQgY29vcmRpbmF0ZXMgb2YgdGhlIGxpZ2h0LiBpZiBsaWdodFszXT0wLCB0cmVhdGVkIGFzIHBhcmFsbGVsIGxpZ2h0LlxcclxcbiAqIEByZXR1cm4gdGhpc1xcclxcbiAqL1xcclxcbk1hdHJpeDQucHJvdG90eXBlLmRyb3BTaGFkb3cgPSBmdW5jdGlvbihwbGFuZSwgbGlnaHQpIHtcXHJcXG4gIHZhciBtYXQgPSBuZXcgTWF0cml4NCgpO1xcclxcbiAgdmFyIGUgPSBtYXQuZWxlbWVudHM7XFxyXFxuXFxyXFxuICB2YXIgZG90ID0gcGxhbmVbMF0gKiBsaWdodFswXSArIHBsYW5lWzFdICogbGlnaHRbMV0gKyBwbGFuZVsyXSAqIGxpZ2h0WzJdICsgcGxhbmVbM10gKiBsaWdodFszXTtcXHJcXG5cXHJcXG4gIGVbIDBdID0gZG90IC0gbGlnaHRbMF0gKiBwbGFuZVswXTtcXHJcXG4gIGVbIDFdID0gICAgIC0gbGlnaHRbMV0gKiBwbGFuZVswXTtcXHJcXG4gIGVbIDJdID0gICAgIC0gbGlnaHRbMl0gKiBwbGFuZVswXTtcXHJcXG4gIGVbIDNdID0gICAgIC0gbGlnaHRbM10gKiBwbGFuZVswXTtcXHJcXG5cXHJcXG4gIGVbIDRdID0gICAgIC0gbGlnaHRbMF0gKiBwbGFuZVsxXTtcXHJcXG4gIGVbIDVdID0gZG90IC0gbGlnaHRbMV0gKiBwbGFuZVsxXTtcXHJcXG4gIGVbIDZdID0gICAgIC0gbGlnaHRbMl0gKiBwbGFuZVsxXTtcXHJcXG4gIGVbIDddID0gICAgIC0gbGlnaHRbM10gKiBwbGFuZVsxXTtcXHJcXG5cXHJcXG4gIGVbIDhdID0gICAgIC0gbGlnaHRbMF0gKiBwbGFuZVsyXTtcXHJcXG4gIGVbIDldID0gICAgIC0gbGlnaHRbMV0gKiBwbGFuZVsyXTtcXHJcXG4gIGVbMTBdID0gZG90IC0gbGlnaHRbMl0gKiBwbGFuZVsyXTtcXHJcXG4gIGVbMTFdID0gICAgIC0gbGlnaHRbM10gKiBwbGFuZVsyXTtcXHJcXG5cXHJcXG4gIGVbMTJdID0gICAgIC0gbGlnaHRbMF0gKiBwbGFuZVszXTtcXHJcXG4gIGVbMTNdID0gICAgIC0gbGlnaHRbMV0gKiBwbGFuZVszXTtcXHJcXG4gIGVbMTRdID0gICAgIC0gbGlnaHRbMl0gKiBwbGFuZVszXTtcXHJcXG4gIGVbMTVdID0gZG90IC0gbGlnaHRbM10gKiBwbGFuZVszXTtcXHJcXG5cXHJcXG4gIHJldHVybiB0aGlzLmNvbmNhdChtYXQpO1xcclxcbn1cXHJcXG5cXHJcXG4vKipcXHJcXG4gKiBNdWx0aXBseSB0aGUgbWF0cml4IGZvciBwcm9qZWN0IHZlcnRleCB0byBwbGFuZSBmcm9tIHRoZSByaWdodC4oUHJvamVjdGVkIGJ5IHBhcmFsbGVsIGxpZ2h0LilcXHJcXG4gKiBAcGFyYW0gbm9ybVgsIG5vcm1ZLCBub3JtWiBUaGUgbm9ybWFsIHZlY3RvciBvZiB0aGUgcGxhbmUuKE5vdCBuZWNlc3NhcnkgdG8gYmUgbm9ybWFsaXplZC4pXFxyXFxuICogQHBhcmFtIHBsYW5lWCwgcGxhbmVZLCBwbGFuZVogVGhlIGNvb3JkaW5hdGUgb2YgYXJiaXRyYXJ5IHBvaW50cyBvbiBhIHBsYW5lLlxcclxcbiAqIEBwYXJhbSBsaWdodFgsIGxpZ2h0WSwgbGlnaHRaIFRoZSB2ZWN0b3Igb2YgdGhlIGRpcmVjdGlvbiBvZiBsaWdodC4oTm90IG5lY2Vzc2FyeSB0byBiZSBub3JtYWxpemVkLilcXHJcXG4gKiBAcmV0dXJuIHRoaXNcXHJcXG4gKi9cXHJcXG5NYXRyaXg0LnByb3RvdHlwZS5kcm9wU2hhZG93RGlyZWN0aW9uYWxseSA9IGZ1bmN0aW9uKG5vcm1YLCBub3JtWSwgbm9ybVosIHBsYW5lWCwgcGxhbmVZLCBwbGFuZVosIGxpZ2h0WCwgbGlnaHRZLCBsaWdodFopIHtcXHJcXG4gIHZhciBhID0gcGxhbmVYICogbm9ybVggKyBwbGFuZVkgKiBub3JtWSArIHBsYW5lWiAqIG5vcm1aO1xcclxcbiAgcmV0dXJuIHRoaXMuZHJvcFNoYWRvdyhbbm9ybVgsIG5vcm1ZLCBub3JtWiwgLWFdLCBbbGlnaHRYLCBsaWdodFksIGxpZ2h0WiwgMF0pO1xcclxcbn07XFxyXFxuXFxyXFxuLyoqXFxyXFxuICogQ29uc3RydWN0b3Igb2YgVmVjdG9yM1xcclxcbiAqIElmIG9wdF9zcmMgaXMgc3BlY2lmaWVkLCBuZXcgdmVjdG9yIGlzIGluaXRpYWxpemVkIGJ5IG9wdF9zcmMuXFxyXFxuICogQHBhcmFtIG9wdF9zcmMgc291cmNlIHZlY3RvcihvcHRpb24pXFxyXFxuICovXFxyXFxudmFyIFZlY3RvcjMgPSBmdW5jdGlvbihvcHRfc3JjKSB7XFxyXFxuICB2YXIgdiA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XFxyXFxuICBpZiAob3B0X3NyYyAmJiB0eXBlb2Ygb3B0X3NyYyA9PT0gJ29iamVjdCcpIHtcXHJcXG4gICAgdlswXSA9IG9wdF9zcmNbMF07IHZbMV0gPSBvcHRfc3JjWzFdOyB2WzJdID0gb3B0X3NyY1syXTtcXHJcXG4gIH0gXFxyXFxuICB0aGlzLmVsZW1lbnRzID0gdjtcXHJcXG59XFxyXFxuXFxyXFxuLyoqXFxyXFxuICAqIE5vcm1hbGl6ZS5cXHJcXG4gICogQHJldHVybiB0aGlzXFxyXFxuICAqL1xcclxcblZlY3RvcjMucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKCkge1xcclxcbiAgdmFyIHYgPSB0aGlzLmVsZW1lbnRzO1xcclxcbiAgdmFyIGMgPSB2WzBdLCBkID0gdlsxXSwgZSA9IHZbMl0sIGcgPSBNYXRoLnNxcnQoYypjK2QqZCtlKmUpO1xcclxcbiAgaWYoZyl7XFxyXFxuICAgIGlmKGcgPT0gMSlcXHJcXG4gICAgICAgIHJldHVybiB0aGlzO1xcclxcbiAgIH0gZWxzZSB7XFxyXFxuICAgICB2WzBdID0gMDsgdlsxXSA9IDA7IHZbMl0gPSAwO1xcclxcbiAgICAgcmV0dXJuIHRoaXM7XFxyXFxuICAgfVxcclxcbiAgIGcgPSAxL2c7XFxyXFxuICAgdlswXSA9IGMqZzsgdlsxXSA9IGQqZzsgdlsyXSA9IGUqZztcXHJcXG4gICByZXR1cm4gdGhpcztcXHJcXG59O1xcclxcblxcclxcbi8qKlxcclxcbiAqIENvbnN0cnVjdG9yIG9mIFZlY3RvcjRcXHJcXG4gKiBJZiBvcHRfc3JjIGlzIHNwZWNpZmllZCwgbmV3IHZlY3RvciBpcyBpbml0aWFsaXplZCBieSBvcHRfc3JjLlxcclxcbiAqIEBwYXJhbSBvcHRfc3JjIHNvdXJjZSB2ZWN0b3Iob3B0aW9uKVxcclxcbiAqL1xcclxcbnZhciBWZWN0b3I0ID0gZnVuY3Rpb24ob3B0X3NyYykge1xcclxcbiAgdmFyIHYgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xcclxcbiAgaWYgKG9wdF9zcmMgJiYgdHlwZW9mIG9wdF9zcmMgPT09ICdvYmplY3QnKSB7XFxyXFxuICAgIHZbMF0gPSBvcHRfc3JjWzBdOyB2WzFdID0gb3B0X3NyY1sxXTsgdlsyXSA9IG9wdF9zcmNbMl07IHZbM10gPSBvcHRfc3JjWzNdO1xcclxcbiAgfSBcXHJcXG4gIHRoaXMuZWxlbWVudHMgPSB2O1xcclxcbn1cXHJcXG5cIiIsInJlcXVpcmUoXCIhIS9zYXZlcHJvai9NTUR3ZWIvd2ViZ2xNTUQvbW1kdGVzdC9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL3NhdmVwcm9qL01NRHdlYi93ZWJnbE1NRC9tbWR0ZXN0L25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS9zYXZlcHJvai9NTUR3ZWIvd2ViZ2xNTUQvbW1kdGVzdC9zcmMvc2hhZGVyc291cmNlLmpzXCIpKSIsIm1vZHVsZS5leHBvcnRzID0gXCJcXG52YXIgVlNIQURFUl9TT1VSQ0UgPSAnYXR0cmlidXRlIHZlYzQgYV9Qb3NpdGlvbjsgXFxcXG4nICtcXG4nYXR0cmlidXRlIHZlYzQgYV9Db2xvcjsgXFxcXG4nICtcXG4ndW5pZm9ybSBtYXQ0IHVfVmlld01hdHJpeDsgXFxcXG4nICtcXG4ndW5pZm9ybSBtYXQ0IHVfUHJvak1hdHJpeDsgXFxcXG4nICtcXG4ndW5pZm9ybSBtYXQ0IHVfTW9kZWxNYXRyaXg7IFxcXFxuJyArXFxuLy8gJ3ZhcnlpbmcgdmVjNCB2X0NvbG9yOyBcXFxcbicgK1xcbi8vICcgYXR0cmlidXRlIHZlYzQgYV9Ob3JtYWw7IFxcXFxuJyArXFxuLy8gJyB1bmlmb3JtIHZlYzMgdV9MaWdodENvbG9yOyBcXFxcbicgK1xcbi8vICcgdW5pZm9ybSB2ZWMzIHVfTGlnaHREaXJlY3Rpb247IFxcXFxuJyArXFxuJ2F0dHJpYnV0ZSB2ZWMyIGFfVGV4Q29vcmQ7IFxcXFxuJyArXFxuJ3ZhcnlpbmcgdmVjMiB2X1RleENvb3JkOyBcXFxcbicgK1xcbid2b2lkIG1haW4oKSB7IFxcXFxuJyArXFxuJyBnbF9Qb3NpdGlvbiA9IHVfUHJvak1hdHJpeCAqIHVfVmlld01hdHJpeCAqIHVfTW9kZWxNYXRyaXggKiBhX1Bvc2l0aW9uOyBcXFxcbicgK1xcbicgdl9UZXhDb29yZCA9IGFfVGV4Q29vcmQ7IFxcXFxuJyArXFxuLy8gJ3ZlYzMgbm9ybWFsID0gbm9ybWFsaXplKHZlYzMoYV9Ob3JtYWwpKTsgXFxcXG4nICtcXG4vLyAnZmxvYXQgbkRvdEwgPSBtYXgoZG90KHVfTGlnaHREaXJlY3Rpb24sIG5vcm1hbCksIDAuMCk7IFxcXFxuJyArXFxuLy8gJ3ZlYzMgZGlmZnVzZSA9IHVfTGlnaHRDb2xvciAqIHZlYzMoYV9Db2xvcikgKiBuRG90TDsgXFxcXG4nICtcXG4vLyAvLyAnIHZfQ29sb3IgPSBhX0NvbG9yOyBcXFxcbicgK1xcbi8vICd2X0NvbG9yID0gdmVjNChkaWZmdXNlLCBhX0NvbG9yLmEpOyBcXFxcbicgK1xcbid9IFxcXFxuJztcXG5cXG52YXIgRlNIQURFUl9TT1VSQ0UgPSAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7IFxcXFxuJyArXFxuJ3VuaWZvcm0gc2FtcGxlcjJEIHVfU2FtcGxlcjA7IFxcXFxuJyArXFxuJ3ZhcnlpbmcgdmVjMiB2X1RleENvb3JkOyBcXFxcbicgK1xcbid2b2lkIG1haW4oKSB7IFxcXFxuJyArXFxuJyB2ZWM0IGNvbG9yMCA9IHRleHR1cmUyRCh1X1NhbXBsZXIwLCB2X1RleENvb3JkKTsgXFxcXG4nICtcXG4nIGdsX0ZyYWdDb2xvciA9IGNvbG9yMDsgXFxcXG4nICtcXG4nfSBcXFxcbic7XCIiLCJyZXF1aXJlKFwiISEvc2F2ZXByb2ovTU1Ed2ViL3dlYmdsTU1EL21tZHRlc3Qvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9zYXZlcHJvai9NTUR3ZWIvd2ViZ2xNTUQvbW1kdGVzdC9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvc2F2ZXByb2ovTU1Ed2ViL3dlYmdsTU1EL21tZHRlc3Qvc3JjL3ZlcnRpY2VzLmpzXCIpKSIsIm1vZHVsZS5leHBvcnRzID0gXCJcXG4vLyB2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KFtcXG4vLyAgICAgLTAuNSwgIDAuNSxcXG4vLyAgICAgLTAuNSwgLTAuNSxcXG4vLyAgICAgIDAuNSwgIDAuNSxcXG4vLyAgICAgIDAuNSwgLTAuNSxcXG4vLyAgICAgXSk7XFxuXFxudmFyIFRleENvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xcbiAgMC4wLCAxLjAsICAwLjAsIDAuMCwgICAxLjAsIDAuMCwgICAxLjAsIDEuMCxcXG4gIDAuMCwgMS4wLCAgMC4wLCAwLjAsICAgMS4wLCAwLjAsICAgMS4wLCAxLjAsXFxuICAxLjAsIDEuMCwgIDAuMCwgMS4wLCAgIDAuMCwgMC4wLCAgIDEuMCwgMC4wLFxcbiAgMS4wLCAxLjAsICAwLjAsIDEuMCwgICAwLjAsIDAuMCwgICAxLjAsIDAuMCxcXG4gIDAuMCwgMC4wLCAgIDEuMCwgMC4wLCAgIDEuMCwgMS4wLCAgMC4wLCAxLjBcXG4gICAgXSk7XFxuXFxuICB2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KFsgICAvLyBDb29yZGluYXRlc1xcbiAgICAgLy8gMS4wLCAxLjAsIDEuMCwgIC0xLjAsIDEuMCwgMS4wLCAgLTEuMCwtMS4wLCAxLjAsICAgMS4wLC0xLjAsIDEuMCwgLy8gdjAtdjEtdjItdjMgZnJvbnRcXG4gICAgIDEuMCwgMS4wLCAzLjAsICAgMS4wLC0xLjAsIDMuMCwgICAxLjAsLTEuMCwtMy4wLCAgIDEuMCwgMS4wLC0zLjAsIC8vIHYwLXYzLXY0LXY1IHJpZ2h0XFxuICAgICAxLjAsIDEuMCwgMy4wLCAgIDEuMCwgMS4wLC0zLjAsICAtMS4wLCAxLjAsLTMuMCwgIC0xLjAsIDEuMCwgMy4wLCAvLyB2MC12NS12Ni12MSB1cFxcbiAgICAtMS4wLCAxLjAsIDMuMCwgIC0xLjAsIDEuMCwtMy4wLCAgLTEuMCwtMS4wLC0zLjAsICAtMS4wLC0xLjAsIDMuMCwgLy8gdjEtdjYtdjctdjIgbGVmdFxcbiAgICAtMS4wLC0xLjAsLTMuMCwgICAxLjAsLTEuMCwtMy4wLCAgIDEuMCwtMS4wLCAzLjAsICAtMS4wLC0xLjAsIDMuMCwgLy8gdjctdjQtdjMtdjIgZG93blxcbiAgICAgMS4wLC0xLjAsLTMuMCwgIC0xLjAsLTEuMCwtMy4wLCAgLTEuMCwgMS4wLC0zLjAsICAgMS4wLCAxLjAsLTMuMCAgLy8gdjQtdjctdjYtdjUgYmFja1xcbiAgXSk7XFxuXFxuXFxuIC8vICB2YXIgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheShbICAgIC8vIENvbG9yc1xcbiAvLyAgICAvLyAxLCAwLCAwLCAgIDEsIDAsIDAsICAgMSwgMCwgMCwgIDEsIDAsIDAsICAgICAvLyB2MC12MS12Mi12MyBmcm9udFxcbiAvLyAgICAxLCAwLCAwLCAgIDEsIDAsIDAsICAgMSwgMCwgMCwgIDEsIDAsIDAsICAgICAvLyB2MC12My12NC12NSByaWdodFxcbiAvLyAgICAxLCAxLCAwLCAgIDEsIDAsIDAsICAgMSwgMCwgMCwgIDEsIDAsIDAsICAgICAvLyB2MC12NS12Ni12MSB1cFxcbiAvLyAgICAxLCAwLCAwLCAgIDEsIDEsIDEsICAgMSwgMCwgMCwgIDEsIDAsIDAsICAgICAvLyB2MS12Ni12Ny12MiBsZWZ0XFxuIC8vICAgIDEsIDAsIDAsICAgMSwgMCwgMCwgICAxLCAxLCAxLCAgMSwgMCwgMCwgICAgIC8vIHY3LXY0LXYzLXYyIGRvd25cXG4gLy8gICAgMSwgMCwgMCwgICAxLCAwLCAwLCAgIDEsIDAsIDAsICAxLCAxLCAx44CAICAgIC8vIHY0LXY3LXY2LXY1IGJhY2tcXG4gLy8gXSk7XFxuXFxuXFxuICB2YXIgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoWyAgICAvLyBOb3JtYWxcXG4gICAgLy8gMC4wLCAwLjAsIDEuMCwgICAwLjAsIDAuMCwgMS4wLCAgIDAuMCwgMC4wLCAxLjAsICAgMC4wLCAwLjAsIDEuMCwgIC8vIHYwLXYxLXYyLXYzIGZyb250XFxuICAgIDEuMCwgMC4wLCAwLjAsICAgMS4wLCAwLjAsIDAuMCwgICAxLjAsIDAuMCwgMC4wLCAgIDEuMCwgMC4wLCAwLjAsICAvLyB2MC12My12NC12NSByaWdodFxcbiAgICAwLjAsIDEuMCwgMC4wLCAgIDAuMCwgMS4wLCAwLjAsICAgMC4wLCAxLjAsIDAuMCwgICAwLjAsIDEuMCwgMC4wLCAgLy8gdjAtdjUtdjYtdjEgdXBcXG4gICAxLjAsIDAuMCwgMC4wLCAgMS4wLCAwLjAsIDAuMCwgIDEuMCwgMC4wLCAwLjAsICAxLjAsIDAuMCwgMC4wLCAgLy8gdjEtdjYtdjctdjIgbGVmdFxcbiAgICAwLjAsMS4wLCAwLjAsICAgMC4wLDEuMCwgMC4wLCAgIDAuMCwxLjAsIDAuMCwgICAwLjAsMS4wLCAwLjAsICAvLyB2Ny12NC12My12MiBkb3duXFxuICAgIDAuMCwgMC4wLDEuMCwgICAwLjAsIDAuMCwxLjAsICAgMC4wLCAwLjAsMS4wLCAgIDAuMCwgMC4wLDEuMCAgIC8vIHY0LXY3LXY2LXY1IGJhY2tcXG4gIF0pO1xcblxcblxcbiAgLy8gSW5kaWNlcyBvZiB0aGUgdmVydGljZXNcXG4gIHZhciBpbmRpY2VzID0gbmV3IFVpbnQ4QXJyYXkoW1xcbiAgICAgMCwgMSwgMiwgICAwLCAyLCAzLCAgICAvLyByaWdodFxcbiAgICAgNCwgNSwgNiwgICA0LCA2LCA3LCAgICAvLyB1cFxcbiAgICAgOCwgOSwxMCwgICA4LDEwLDExLCAgICAvLyBsZWZ0XFxuICAgIDEyLDEzLDE0LCAgMTIsMTQsMTUsICAgIC8vIGRvd25cXG4gICAgMTYsMTcsMTgsICAxNiwxOCwxOSAgICAvLyBiYWNrXFxuICAgIC8vIDIwLDIxLDIyLCAgMjAsMjIsMjMgICAgIC8vIGJhY2sgZnJvbnRcXG4gXSk7XCIiXSwic291cmNlUm9vdCI6IiJ9